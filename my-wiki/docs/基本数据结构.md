# 基本数据结构

创建者: Sakura
创建时间: 2025年4月8日 13:26
类别: 学习笔记
上次更新时间: 2025年11月30日 11:32

- 栈
    - 单调栈
        - 单调栈的基本概念
            
            单调栈是一种特殊的栈结构，其核心特点是：栈内元素（或其对应的值）保持单调递增或单调递减的顺序。根据单调性不同，分为两种：
            
            - 单调递增栈：栈内元素从栈底到栈顶依次递增（即下一个元素比上一个大）。
            - 单调递减栈：栈内元素从栈底到栈顶依次递减（即下一个元素比上一个小）。
        - 核心思想：
            
            通过维护栈的单调性，使得对于栈中的每个元素，其左右侧满足单调性条件的元素可以被快速找到（例如 “下一个更大元素”“下一个更小元素”）。每个元素最多入栈和出栈一次，时间复杂度为 O(n)，远优于暴力枚举的 O(n²)。
            
        - 单调栈的工作流程
            
            以单调递增栈为例（寻找每个元素的下一个更大元素），步骤如下：
            
            - 初始化栈：用于存储元素下标（通常存下标而非值，方便后续计算位置关系）。
            - 遍历数组：
                - 对于当前元素 `nums[i]`，若栈不为空且 `nums[i] > nums[栈顶下标]`，则栈顶元素的 “下一个更大元素” 就是 `nums[i]`，弹出栈顶并记录结果。
                - 重复上述步骤，直到栈为空或当前元素不大于栈顶元素。
                - 将当前元素的下标入栈，继续遍历。
        - 关键性质：
            - 栈中始终保持元素下标对应的值单调递增。
            - 每个元素入栈后，只有当右侧出现 “破坏单调性” 的元素时才会被弹出（即找到右侧第一个更大 / 更小的元素）。
        
        <aside>
        ✅
        
        </aside>
        
- 队列
    - 双端队列(deque)
        
        双端队列（Double-ended Queue，`std::deque`）是一种动态数组结构，支持在队列两端高效插入和删除元素。与`vector`相比，其优势在于头部操作的时间复杂度为O(1)，且扩容时无需整体复制元素。
        
        1. 核心操作函数
            1. 构造与初始化
                
                ```cpp
                std::deque<int> d1;                // 空队列
                std::deque<int> d2(5, 10);         // 初始化为5个10
                std::deque<int> d3 = {1, 2, 3};    // 列表初始化
                std::deque<int> d4(d3);            // 拷贝构造
                ```
                
                - 默认构造
                
                ```cpp
                std::deque<int> deq;  // 创建空双端队列
                ```
                
                - 带初始大小构造
                
                ```cpp
                std::deque<int> deq(5);  // 初始大小为5，元素默认初始化为0
                ```
                
                - 带初始值构造
                
                ```cpp
                std::deque<int> deq(3, 10);  // [10, 10, 10]
                ```
                
                - 复制构造
                
                ```cpp
                std::deque<int> deq2(deq1);  // 复制deq1的内容到deq2
                ```
                
                - 范围构造
                
                ```cpp
                std::vector<int> vec = {1, 2, 3};
                std::deque<int> deq(vec.begin(), vec.end());  // [1, 2, 3]
                ```
                
            2. 元素访问
                
                ```cpp
                d3[0] = 10;          // 随机访问（不检查越界）
                d3.at(1) = 20;       // 随机访问（检查越界）
                int front = d3.front();  // 队首元素
                int back = d3.back();    // 队尾元素
                ```
                
                - 随机访问
                
                ```cpp
                deq[2];      // 不检查越界，直接访问第3个元素
                deq.at(2);   // 检查越界，越界时抛出std::out_of_range异常
                ```
                
                - 首尾元素
                
                ```cpp
                deq.front();  // 返回头部元素引用
                deq.back();   // 返回尾部元素引用
                ```
                
            3. 插入与删除
                
                ```cpp
                d3.push_back(4);     // 尾部插入：O(1)
                d3.push_front(0);    // 头部插入：O(1)
                d3.insert(d3.begin()+2, 99);  // 中间插入：O(n)
                
                d3.pop_back();       // 删除尾部：O(1)
                d3.pop_front();      // 删除头部：O(1)
                d3.erase(d3.begin()+1);  // 删除指定位置：O(n)
                ```
                
                - 添加元素
                
                ```cpp
                deq.push_back(10);    // 尾部插入：O(1)
                deq.push_front(5);    // 头部插入：O(1)
                deq.insert(deq.begin()+2, 7);  // 中间插入：O(n)
                ```
                
                - 删除元素
                
                ```cpp
                deq.pop_back();     // 删除尾部元素：O(1)
                deq.pop_front();    // 删除头部元素：O(1)
                deq.erase(deq.begin()+1);  // 删除指定位置：O(n)
                ```
                
                - 调整大小
                
                ```cpp
                deq.resize(10);     // 扩展到10个元素，新元素默认初始化为0
                deq.resize(5);      // 截断为5个元素
                ```
                
                - 清空队列
                
                ```cpp
                deq.clear();        // 清空所有元素，size变为0
                ```
                
            4. 容量与大小
                
                ```cpp
                bool empty = d3.empty();    // 判断是否为空
                size_t size = d3.size();    // 当前元素数量
                d3.resize(10);              // 调整大小（新元素默认初始化）
                d3.shrink_to_fit();         // 释放未使用内存（C++11+）
                ```
                
                - 大小与空判断
                
                ```cpp
                deq.size();     // 返回当前元素数量
                deq.empty();    // 判断是否为空
                ```
                
                - 最大容量
                
                ```cpp
                deq.max_size();  // 返回理论最大容量（受系统限制）
                ```
                
                - 内存优化
                
                ```cpp
                deq.shrink_to_fit();  // 释放未使用的内存（C++11+）
                ```
                
            5. 迭代器
                
                ```cpp
                // 正向遍历
                for (auto it = d3.begin(); it != d3.end(); ++it) {
                    std::cout << *it << " ";
                }
                
                // 反向遍历
                for (auto rit = d3.rbegin(); rit != d3.rend(); ++rit) {
                    std::cout << *rit << " ";
                }
                ```
                
                - 正向迭代器
                
                ```cpp
                for (auto it = deq.begin(); it != deq.end(); ++it) {
                    std::cout << *it << " ";  // 顺序遍历
                }
                ```
                
                - 反向迭代器
                
                ```cpp
                for (auto rit = deq.rbegin(); rit != deq.rend(); ++rit) {
                    std::cout << *rit << " ";  // 逆序遍历
                }
                ```
                
                - 常量迭代器
                
                ```cpp
                for (auto cit = deq.cbegin(); cit != deq.cend(); ++cit) {
                    // 只读访问，无法修改元素
                }
                ```
                
            6. 其他操作
                - 交换内容
                
                ```cpp
                deq1.swap(deq2);  // 交换deq1和deq2的内容
                ```
                
                - 赋值操作
                
                ```cpp
                deq = {1, 2, 3};  // 使用初始化列表赋值
                ```
                
                - 比较操作
                
                ```cpp
                deq1 == deq2;  // 比较内容是否相等
                deq1 < deq2;   // 字典序比较
                ```
                
        2. 底层原理
            - 内存布局：`deque`由多个固定大小的连续存储块组成，通过中控器管理这些块的地址。
            - 扩容机制：扩容时仅需分配新块，无需复制原有元素，效率高于`vector`。
        3. 时间复杂度
            
            
            | 操作 | 时间复杂度 |
            | --- | --- |
            | 随机访问 | O(1) |
            | 头部插入/删除 | O(1) |
            | 尾部插入/删除 | O(1) |
            | 中间插入/删除 | O(n) |
            | 迭代器递增/递减 | O(1) |
        4. 应用场景
            - 双向队列：实现栈或队列的底层结构。
            - 滑动窗口算法：维护窗口内元素的高效进出。
            - 任务调度：支持从队首和队尾同时处理任务。
        5. 与其他容器的对比
            
            
            | 容器 | 随机访问 | 头部插入 | 尾部插入 | 中间插入 |
            | --- | --- | --- | --- | --- |
            | `vector` | O(1) | O(n) | O(1) | O(n) |
            | `deque` | O(1) | O(1) | O(1) | O(n) |
            | `list` | O(n) | O(1) | O(1) | O(1) |
        6. 注意事项
            - 迭代器失效：插入或删除元素可能导致迭代器失效。
            - 内存开销：中控器和多个存储块可能带来额外内存开销。
            - 异常安全：`push_back/push_front`在内存分配失败时抛出`std::bad_alloc`。
        7. 示例代码
            
            ```cpp
            #include <deque>
            #include <iostream>
            
            int main() {
                // 创建双端队列
                std::deque<int> d = {1, 2, 3};
            
                // 首尾操作
                d.push_front(0);    // [0, 1, 2, 3]
                d.push_back(4);     // [0, 1, 2, 3, 4]
            
                // 随机访问
                std::cout << "Element at index 2: " << d[2] << std::endl;  // 输出: 2
            
                // 遍历
                std::cout << "Elements: ";
                for (int num : d) {
                    std::cout << num << " ";
                }
                std::cout << std::endl;
            
                // 删除操作
                d.pop_front();      // [1, 2, 3, 4]
                d.erase(d.begin()+1);  // [1, 3, 4]
            
                return 0;
            }
            ```
            
            - 输出结果
            
            ```
            Element at index 2: 2
            Elements: 0 1 2 3 4
            ```
            
        8. 总结
        - 优势：支持高效的首尾操作和随机访问。
        - 劣势：内存布局复杂，中间插入效率低。
        - 适用场景：需要频繁在首尾插入/删除元素，同时保留随机访问能力的场景。
    - 循环队列(Circular_Queue)
        
        环形队列（Circular Queue）是一种特殊的队列数据结构，它将队列的首尾相连形成一个环形缓冲区。这种结构可以更有效地利用内存空间，避免普通队列在出队操作后出现的"假溢出"问题。
        
        1. 环形队列的核心概念
            1. 基本结构：
                - 使用数组作为底层存储
                - 通过两个指针（front和rear）管理队列的头部和尾部
                - 首尾相连形成环形结构
            2. 关键特性：
                - 入队（Enqueue）和出队（Dequeue）操作的时间复杂度均为O(1)
                - 空间利用率高，避免了普通队列的"假溢出"问题
                - 需要区分队列空和队列满的状态
            3. 空满状态判断：
                - 方法1：浪费一个存储位置，使队列满时仍有一个空位
                - 方法2：使用额外的计数器记录元素数量
                - 方法3：使用标志位标记队列状态
        2. C++实现环形队列
            
            下面是一个使用C++实现的环形队列，采用浪费一个位置的方式区分空满状态：
            
            ```cpp
            #include <iostream>
            #include <stdexcept>
            
            template<typename T>
            class CircularQueue {
            private:
                T* data;           // 存储队列元素的数组
                int capacity;      // 队列的总容量（包含一个浪费的位置）
                int front;         // 队头指针，指向队列第一个元素
                int rear;          // 队尾指针，指向队列最后一个元素的下一个位置
            
            public:
                // 构造函数，初始化队列
                explicit CircularQueue(int size) : capacity(size + 1), front(0), rear(0) {
                    data = new T[capacity];
                }
            
                // 析构函数，释放内存
                ~CircularQueue() {
                    delete[] data;
                }
            
                // 判断队列是否为空
                bool isEmpty() const {
                    return front == rear;
                }
            
                // 判断队列是否已满
                bool isFull() const {
                    return (rear + 1) % capacity == front;
                }
            
                // 获取队列中的元素数量
                int size() const {
                    return (rear - front + capacity) % capacity;
                }
            
                // 入队操作
                void enqueue(const T& value) {
                    if (isFull()) {
                        throw std::overflow_error("Queue is full");
                    }
                    data[rear] = value;
                    rear = (rear + 1) % capacity;
                }
            
                // 出队操作
                void dequeue() {
                    if (isEmpty()) {
                        throw std::underflow_error("Queue is empty");
                    }
                    front = (front + 1) % capacity;
                }
            
                // 获取队头元素
                T frontValue() const {
                    if (isEmpty()) {
                        throw std::underflow_error("Queue is empty");
                    }
                    return data[front];
                }
            
                // 获取队尾元素
                T rearValue() const {
                    if (isEmpty()) {
                        throw std::underflow_error("Queue is empty");
                    }
                    // 计算实际队尾位置
                    int tailIndex = (rear - 1 + capacity) % capacity;
                    return data[tailIndex];
                }
            
                // 打印队列中的所有元素
                void print() const {
                    if (isEmpty()) {
                        std::cout << "Queue is empty" << std::endl;
                        return;
                    }
            
                    std::cout << "Queue elements: ";
                    int count = size();
                    for (int i = 0; i < count; ++i) {
                        int index = (front + i) % capacity;
                        std::cout << data[index] << " ";
                    }
                    std::cout << std::endl;
                }
            };
            ```
            
            - 实现说明
            1. 模板类设计：
                - 使用模板<typename T>支持任意数据类型
                - 构造函数接受一个整数参数，实际容量为参数值加1
            2. 指针管理：
                - `front`：指向队列的第一个有效元素
                - `rear`：指向队列最后一个元素的下一个位置
            3. 关键操作：
                - 入队：在`rear`位置存储元素，然后`rear`指针后移
                - 出队：直接将`front`指针后移，无需实际删除元素
                - 队尾元素计算：使用`(rear - 1 + capacity) % capacity`确保正确获取队尾位置
            4. 边界条件处理：
                - 通过`(index + 1) % capacity`实现指针循环
                - 空队列：`front == rear`
                - 满队列：`(rear + 1) % capacity == front`
        3. 使用示例
            
            下面是一个简单的测试程序，演示如何使用上述环形队列：
            
            ```cpp
            #include <iostream>
            
            int main() {
                // 创建一个容量为3的环形队列
                CircularQueue<int> queue(3);
            
                try {
                    // 测试空队列状态
                    std::cout << "Is empty: " << (queue.isEmpty() ? "Yes" : "No") << std::endl;
                    std::cout << "Is full: " << (queue.isFull() ? "Yes" : "No") << std::endl;
            
                    // 入队操作
                    queue.enqueue(10);
                    queue.enqueue(20);
                    queue.enqueue(30);
                    queue.print();  // 输出: Queue elements: 10 20 30
            
                    // 测试满队列状态
                    std::cout << "Is full: " << (queue.isFull() ? "Yes" : "No") << std::endl;
            
                    // 获取队头和队尾元素
                    std::cout << "Front: " << queue.frontValue() << std::endl;  // 输出: 10
                    std::cout << "Rear: " << queue.rearValue() << std::endl;    // 输出: 30
            
                    // 出队操作
                    queue.dequeue();
                    std::cout << "After dequeue, Front: " << queue.frontValue() << std::endl;  // 输出: 20
            
                    // 再次入队
                    queue.enqueue(40);
                    queue.print();  // 输出: Queue elements: 20 30 40
            
                } catch (const std::exception& e) {
                    std::cerr << "Error: " << e.what() << std::endl;
                }
            
                return 0;
            }
            ```
            
        4. 环形队列的优缺点
            
            优点：
            
            - 空间利用率高，避免了普通队列的"假溢出"问题
            - 入队和出队操作的时间复杂度均为O(1)
            - 适合用于需要循环利用缓冲区的场景，如音频/视频流处理
            
            缺点：
            
            - 需要额外的逻辑来区分队列空和满的状态
            - 固定容量，需要预先分配内存
            - 实现比普通队列复杂，需要处理指针循环问题
        5. 优化方向
            1. 动态扩容：当队列满时自动扩展容量
            2. 双端队列：支持从队列两端进行插入和删除操作
            3. 线程安全：在多线程环境下使用互斥锁或原子操作保证线程安全
            4. 无锁实现：使用CAS（Compare-and-Swap）等技术实现无锁环形队列
        
        环形队列是一种非常实用的数据结构，特别适合需要高效处理循环缓冲区的场景。理解其实现原理和关键细节对于开发高性能系统至关重要。
        
    - 优先队列(堆heap)
        
        优先队列（Priority Queue）是一种特殊的队列，其元素按优先级排序，而非FIFO（先进先出）。每次从队列中取出的元素都是优先级最高的元素。C++标准库通过`std::priority_queue`提供了这一数据结构，它基于堆（Heap）实现，默认是最大堆。
        
        1. 优先队列的核心特性
            - 基于堆结构：内部使用堆（完全二叉树）维护元素优先级。
            - 动态调整：插入和删除操作的时间复杂度为O(log n)。
            - 固定访问点：只能访问队首元素（优先级最高的元素）。
        2. 优先队列的定义与模板参数
            
            ```cpp
            #include <queue>
            
            template<
                class T,
                class Container = std::vector<T>,
                class Compare = std::less<typename Container::value_type>
            > class priority_queue;
            ```
            
            - T：元素类型。
            - Container：底层容器，默认是`vector`，需支持`front()`、`push_back()`、`pop_back()`。
            - Compare：比较函数，默认`std::less`（最大堆），使用`std::greater`可改为最小堆。
        3. 常用操作
            
            
            | **操作** | **函数** | **时间复杂度** | **说明** |
            | --- | --- | --- | --- |
            | **插入元素** | `push(value)` | O(log n) | 将元素插入队列，并调整堆结构。 |
            | **删除队首元素** | `pop()` | O(log n) | 删除优先级最高的元素（堆顶）。 |
            | **获取队首元素** | `top()` | O(1) | 返回优先级最高的元素，但不删除。 |
            | **判断队列是否为空** | `empty()` | O(1) | 若队列为空，返回`true`。 |
            | **获取队列大小** | `size()` | O(1) | 返回队列中元素的数量。 |
        4. 最大堆与最小堆
            - 最大堆（默认）
            
            ```cpp
            #include <iostream>
            #include <queue>
            
            int main() {
                std::priority_queue<int> maxHeap;  // 默认最大堆
                maxHeap.push(3);
                maxHeap.push(1);
                maxHeap.push(2);
                std::cout << "最大堆顶元素：" << maxHeap.top() << std::endl;  // 输出：3
                return 0;
            }
            ```
            
            - 最小堆
            
            ```cpp
            #include <iostream>
            #include <queue>
            
            int main() {
                std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;
                minHeap.push(3);
                minHeap.push(1);
                minHeap.push(2);
                std::cout << "最小堆顶元素：" << minHeap.top() << std::endl;  // 输出：1
                return 0;
            }
            ```
            
        5. 自定义类型的优先队列
            - 重载`<`运算符
            
            ```cpp
            struct Person {
                std::string name;
                int age;
                // 年龄大的优先级高（最大堆）
                bool operator<(const Person& other) const {
                    return age < other.age;
                }
            };
            
            std::priority_queue<Person> pq;
            pq.push({"Alice", 25});
            pq.push({"Bob", 30});
            std::cout << "优先级最高的人：" << pq.top().name << std::endl;  // 输出：Bob
            ```
            
            - 使用Lambda或函数对象
            
            ```cpp
            struct Task {
                int id;
                int priority;
            };
            
            // 自定义比较函数（优先级高的任务先执行）
            auto cmp = [](const Task& a, const Task& b) {
                return a.priority < b.priority;
            };
            
            std::priority_queue<Task, std::vector<Task>, decltype(cmp)> taskQueue(cmp);
            taskQueue.push({1, 3});  // 优先级3的任务
            taskQueue.push({2, 1});  // 优先级1的
            ```
            
        6. 高级操作与技巧
            - 批量初始化
            
            ```cpp
            std::vector<int> nums = {3, 1, 4, 1, 5};
            // 方法1：逐个插入（O(n log n)）
            std::priority_queue<int> pq1;
            for (int num : nums) pq1.push(num);
            
            // 方法2：构造函数（O(n)）
            std::priority_queue<int> pq2(nums.begin(), nums.end())
            ```
            
            - 修改队首元素
            
            ```cpp
            if (!pq.empty()) {
                int top = pq.top();
                pq.pop();
                pq.push(top + 5);  // 修改后重新插入
            }
            ```
            
            - 清空队列
            
            ```cpp
            // 方法1：逐个弹出
            while (!pq.empty()) pq.pop();
            
            // 方法2：交换空队列（效率更高）
            std::priority_queue<int> empty;
            pq.swap(empty);
            ```
            
        7. 常见应用场景
            - Top-K问题
            
            ```cpp
            // 获取数组中最小的K个数
            std::vector<int> getSmallestK(const std::vector<int>& arr, int k) {
                std::priority_queue<int> maxHeap;  // 最大堆
                for (int num : arr) {
                    maxHeap.push(num);
                    if (maxHeap.size() > k) {
                        maxHeap.pop();  // 弹出最大值
                    }
                }
                // 堆中剩下的是最小的K个数
            }
            ```
            
            - Dijkstra最短路径算法
            
            ```cpp
            using PII = std::pair<int, int>;  // {距离, 节点编号}
            std::priority_queue<PII, std::vector<PII>, std::greater<PII>> pq;
            pq.push({0, start});  // 从起点开始，距离为0
            
            while (!pq.empty()) {
                auto [dist, u] = pq.top();
                pq.pop();
                // 处理节点u
            }
            ```
            
            - 合并K个有序链表
            
            ```cpp
            struct ListNode {
                int val;
                ListNode* next;
            };
            
            ListNode* mergeKLists(std::vector<ListNode*>& lists) {
                auto cmp = [](const ListNode* a, const ListNode* b) {
                    return a->val > b->val;  // 最小堆
                };
                std::priority_queue<ListNode*, std::vector<ListNode*>, decltype(cmp)> pq(cmp);
            
                for (ListNode* node : lists) {
                    if (node) pq.push(node);
                }
            
                // 合并逻辑...
            }
            ```
            
        8. 注意事项
        9. 空队列检查：调用`top()`或`pop()`前必须确保队列非空。
        10. 比较函数严格弱序：避免`operator<`或自定义比较函数导致的重复元素判断错误。
        11. 性能优化：批量插入时使用构造函数`O(n)`而非逐个插入`O(n log n)`.
        
        ### **总结**
        
        C++优先队列通过灵活的比较函数支持最大堆和最小堆，适用于动态维护优先级的场景。其核心操作的时间复杂度为O(log n)，结合自定义类型和Lambda表达式，能高效解决任务调度、图算法、数据筛选等问题。
        
- 哈希表
    - **`std::map`有序哈希表**
        - 基本定义以及底层逻辑特性
            - 底层实现
                - `std::map` 是基于红黑树（一种自平衡的二叉搜索树）实现的。红黑树是一种特殊的二叉搜索树，它在每个节点上增加了一个存储位来表示节点的颜色（红色或黑色），并通过一些规则（红黑树的性质）来确保树的高度始终保持在 O(log n)，从而保证了插入、删除和查找操作的时间复杂度为O(log n)。
            - 特性
                - 有序性：`std::map` 会根据键的大小对元素进行排序，默认使用 `std::less<Key>` 作为比较函数，即键按照升序排列。因此，遍历 `std::map` 时，元素会按照键的升序依次被访问。
                - 唯一键：`std::map` 中的键是唯一的，即每个键只能对应一个值。如果插入一个已经存在的键，会更新该键对应的值。
                - 内存开销：由于使用红黑树，每个节点需要额外的指针和颜色信息，因此内存开销相对较大。
            - 适用场景
                - 需要有序遍历：当需要按照键的顺序遍历元素时，`std::map` 是一个不错的选择。例如，在统计单词出现频率并按照字母顺序输出结果的场景中，使用 `std::map` 可以方便地实现。
                - 频繁查找和插入删除操作：由于红黑树的平衡性，`std::map` 在插入、删除和查找操作上的时间复杂度都是O(log n)，适用于需要频繁进行这些操作的场景`。`
            - 代码示例
                
                ```cpp
                #include <iostream>
                #include <map>
                int main() {
                    std::map<int, std::string> myMap;
                    myMap[1] = "apple";
                    myMap[2] = "banana";
                    myMap[3] = "cherry";
                
                    // 遍历 map
                    for (const auto& pair : myMap) {
                        std::cout << pair.first << ": " << pair.second << std::endl;
                    }
                
                    return 0;
                }
                ```
                
            
            <aside>
            ⚠️
            
            `std::map`可以把vector<int>类作为自己的键值,但是`std::unordered` 不可以将它作为自己的键值,是因为构成这两种数据结构的基础不一样,`std::map` 是由红黑树作为底层的.`std::unordered` 是由哈希表作为底层的.
            
            `std::map` 键值要求:只需满足可以`std::map` 要求键类型能够进行比较，也就是要支持 `<` 运算符。红黑树在插入和查找元素时，会利用 `<` 运算符来确定元素的位置.
            
            `std::unordered` 键值要求:键类型能进行相等性比较（支持 `==` 运算符），并且要有一个哈希函数能将键类型的对象映射成 `std::size_t` 类型的哈希值。
            
            </aside>
            
    - `std::unordered`无序哈希表
        - 基本定义以及底层逻辑特性
            - 底层实现
                - `std::unordered_map` 是基于哈希表实现的。哈希表通过哈希函数将键映射到一个哈希值，然后根据哈希值将元素存储在一个数组（桶）中。当发生哈希冲突（不同的键映射到相同的哈希值）时，通常会使用链表或其他方法（如开放寻址法）来解决冲突。
            - 函数原型
                - 类模板定义
                
                ```cpp
                namespace std {
                template<
                    class Key,                          // 键类型
                    class T,                            // 值类型
                    class Hash = std::hash<Key>,        // 哈希函数类型（默认使用 std::hash）
                    class KeyEqual = std::equal_to<Key>, // 键相等比较类型（默认使用 std::equal_to）
                    class Allocator = std::allocator<std::pair<const Key, T>> // 内存分配器
                > class unordered_map;
                }
                ```
                
                - 构造函数
                
                ```cpp
                // 默认构造函数
                unordered_map();
                explicit unordered_map(
                    size_t bucket_count,               // 初始桶数量
                    const Hash& hash = Hash(),         // 哈希函数实例
                    const KeyEqual& equal = KeyEqual(), // 相等比较函数实例
                    const Allocator& alloc = Allocator() // 分配器实例
                );
                
                // 范围构造函数
                template<class InputIt>
                unordered_map(
                    InputIt first, InputIt last,       // 迭代器范围
                    size_t bucket_count = /* 实现定义 */,
                    const Hash& hash = Hash(),
                    const KeyEqual& equal = KeyEqual(),
                    const Allocator& alloc = Allocator()
                );
                
                // 初始化列表构造函数
                unordered_map(
                    std::initializer_list<std::pair<const Key, T>> init,
                    size_t bucket_count = /* 实现定义 */,
                    const Hash& hash = Hash(),
                    const KeyEqual& equal = KeyEqual(),
                    const Allocator& alloc = Allocator()
                );
                
                // 拷贝构造函数
                unordered_map(const unordered_map& other);
                unordered_map(const unordered_map& other, const Allocator& alloc);
                
                // 移动构造函数
                unordered_map(unordered_map&& other) noexcept;
                unordered_map(unordered_map&& other, const Allocator& alloc);
                ```
                
                - 赋值运算符
                
                ```cpp
                // 拷贝赋值
                unordered_map& operator=(const unordered_map& other);
                
                // 移动赋值
                unordered_map& operator=(unordered_map&& other) noexcept(
                    allocator_traits<Allocator>::is_always_equal::value &&
                    std::is_nothrow_swappable_v<Hash> &&
                    std::is_nothrow_swappable_v<KeyEqual>
                );
                
                // 初始化列表赋值
                unordered_map& operator=(std::initializer_list<std::pair<const Key, T>> ilist);
                ```
                
                - 迭代器
                
                ```cpp
                // 普通迭代器
                iterator begin() noexcept;
                const_iterator begin() const noexcept;
                const_iterator cbegin() const noexcept;
                
                iterator end() noexcept;
                const_iterator end() const noexcept;
                const_iterator cend() const noexcept;
                
                // 反向迭代器
                reverse_iterator rbegin() noexcept;
                const_reverse_iterator rbegin() const noexcept;
                const_reverse_iterator crbegin() const noexcept;
                
                reverse_iterator rend() noexcept;
                const_reverse_iterator rend() const noexcept;
                const_reverse_iterator crend() const noexcept;
                ```
                
                - 容量
                
                ```cpp
                bool empty() const noexcept;
                size_t size() const noexcept;
                size_t max_size() const noexcept;
                ```
                
                - 元素访问
                
                ```cpp
                // 下标操作符（若键不存在，会插入默认值）
                T& operator[](const Key& key);
                T& operator[](Key&& key);
                
                // at() 方法（若键不存在，抛出 std::out_of_range）
                T& at(const Key& key);
                const T& at(const Key& key) const;
                ```
                
                - 修改操作
                
                ```cpp
                // 插入单个元素
                std::pair<iterator, bool> insert(const std::pair<const Key, T>& value);
                std::pair<iterator, bool> insert(std::pair<const Key, T>&& value);
                
                // 插入提示版本
                template<class P>
                std::pair<iterator, bool> insert(P&& value);
                
                iterator insert(const_iterator hint, const std::pair<const Key, T>& value);
                iterator insert(const_iterator hint, std::pair<const Key, T>&& value);
                
                template<class P>
                iterator insert(const_iterator hint, P&& value);
                
                // 范围插入
                template<class InputIt>
                void insert(InputIt first, InputIt last);
                
                // 初始化列表插入
                void insert(std::initializer_list<std::pair<const Key, T>> ilist);
                
                // 构造并插入（若键不存在）
                template<class... Args>
                std::pair<iterator, bool> emplace(Args&&... args);
                
                template<class... Args>
                iterator emplace_hint(const_iterator hint, Args&&... args);
                
                // 插入或赋值（C++17）
                template<class M>
                std::pair<iterator, bool> insert_or_assign(const Key& k, M&& obj);
                template<class M>
                std::pair<iterator, bool> insert_or_assign(Key&& k, M&& obj);
                template<class M>
                iterator insert_or_assign(const_iterator hint, const Key& k, M&& obj);
                template<class M>
                iterator insert_or_assign(const_iterator hint, Key&& k, M&& obj);
                
                // 删除元素
                size_t erase(const Key& key);
                iterator erase(const_iterator pos);
                iterator erase(const_iterator first, const_iterator last);
                
                // 交换内容
                void swap(unordered_map& other) noexcept(
                    allocator_traits<Allocator>::is_always_equal::value &&
                    std::is_nothrow_swappable_v<Hash> &&
                    std::is_nothrow_swappable_v<KeyEqual>
                );
                
                // 清空容器
                void clear() noexcept;
                ```
                
                - 查找操作
                
                ```cpp
                // 查找元素
                iterator find(const Key& key);
                const_iterator find(const Key& key) const;
                
                // 统计元素数量（0 或 1）
                size_t count(const Key& key) const;
                
                // 检查键是否存在（C++20）
                bool contains(const Key& key) const;
                
                // 返回匹配的元素范围（通常仅 0 或 1 个元素）
                std::pair<iterator, iterator> equal_range(const Key& key);
                std::pair<const_iterator, const_iterator> equal_range(const Key& key) const;
                ```
                
                - 桶接口
                
                ```cpp
                // 桶数量
                size_t bucket_count() const noexcept;
                size_t max_bucket_count() const noexcept;
                
                // 特定桶中的元素数量
                size_t bucket_size(size_t n) const;
                
                // 返回键所在的桶
                size_t bucket(const Key& key) const;
                ```
                
                - 哈希策略
                
                ```cpp
                // 负载因子（元素数/桶数）
                float load_factor() const noexcept;
                float max_load_factor() const noexcept;
                void max_load_factor(float ml);
                
                // 重新哈希
                void rehash(size_t count);
                void reserve(size_t count);
                ```
                
                - 观察者
                
                ```cpp
                // 返回哈希函数实例
                Hash hash_function() const;
                
                // 返回相等比较函数实例
                KeyEqual key_eq() const;
                ```
                
                - 分配器
                
                ```cpp
                Allocator get_allocator() const noexcept;
                ```
                
                - 非成员函数
                
                ```cpp
                // 比较运算符
                template<class Key, class T, class Hash, class KeyEqual, class Alloc>
                bool operator==(
                    const std::unordered_map<Key, T, Hash, KeyEqual, Alloc>& lhs,
                    const std::unordered_map<Key, T, Hash, KeyEqual, Alloc>& rhs
                );
                
                // 交换函数
                template<class Key, class T, class Hash, class KeyEqual, class Alloc>
                void swap(
                    std::unordered_map<Key, T, Hash, KeyEqual, Alloc>& lhs,
                    std::unordered_map<Key, T, Hash, KeyEqual, Alloc>& rhs
                ) noexcept(noexcept(lhs.swap(rhs)));
                ```
                
                - 说明
                    - 默认参数：当使用自定义键类型（如 `Point`）时，需显式提供 `Hash` 和 `KeyEqual` 类型（如 `PointHash` 和 `operator==`）。
                    - 异常安全：部分操作提供强异常保证（如 `insert`），部分提供基本保证（如 `rehash`）。
                    - 迭代器失效：插入操作可能因重新哈希导致迭代器失效，但删除操作仅使被删除元素的迭代器失效。
            - 特性
                - 无序性：`std::unordered_map` 中的元素是无序的，即遍历元素时，元素的顺序是不确定的，不依赖于键的大小。
                - 唯一键：同样，`std::unordered_map` 中的键也是唯一的，插入已存在的键会更新对应的值。
                - 平均时间复杂度：在平均情况下，插入、删除和查找操作的时间复杂度为 O(1)，但在最坏情况下（哈希冲突严重），时间复杂度可能会退化为 O(n)。
                - 内存开销：哈希表需要额外的空间来存储桶和处理哈希冲突，因此内存开销相对较大，尤其是在哈希冲突较多的情况下。
            - 适用场景
                - 快速查找：当需要快速查找元素，且对元素的顺序没有要求时，`std::unordered_map` 是更好的选择。例如，在缓存系统中，使用 `std::unordered_map` 可以快速查找缓存项。
                - 数据量较大：对于大规模数据，`std::unordered_map` 的平均时间复杂度优势更为明显。
            - 代码示例
                
                ```cpp
                #include <iostream>
                #include <unordered_map>
                int main() {
                    std::unordered_map<int, std::string> myUnorderedMap;
                    myUnorderedMap[1] = "apple";
                    myUnorderedMap[2] = "banana";
                    myUnorderedMap[3] = "cherry";
                
                    // 遍历 unordered_map
                    for (const auto& pair : myUnorderedMap) {
                        std::cout << pair.first << ": " << pair.second << std::endl;
                    }
                
                    return 0;
                }
                ```
                
        - 操作函数
            - 基本操作函数
                - 插入元素
                    - `insert()`：插入键值对，若键已存在则不插入。
                    - `emplace()`：原地构造键值对，效率更高。
                    - `operator[]`：插入或访问元素，若键不存在则自动插入默认值。
                    
                    ```cpp
                    #include <unordered_map>#include <string>
                    
                    std::unordered_map<int, std::string> map;
                    
                    // 方式 1：使用 insert()
                    map.insert({1, "apple"});           // 插入 {1, "apple"}
                    map.insert({1, "banana"});          // 无效：键 1 已存在
                    
                    // 方式 2：使用 emplace()
                    map.emplace(2, "cherry");           // 原地构造 {2, "cherry"}
                    
                    // 方式 3：使用 operator[]
                    map[3] = "date";                    // 插入 {3, "date"}
                    map[3] = "elderberry";              // 修改键 3 的值为 "elderberry"
                    map[4];                             // 插入 {4, ""}（默认构造的 string）
                    ```
                    
                - 查找元素
                    - `find()`：查找键，返回迭代器。
                        
                        `find()` 用于快速查找指定键（key）是否存在。
                        
                        - 函数原型
                            
                            ```cpp
                            iterator find(const Key& key);                // 非 const 版本
                            const_iterator find(const Key& key) const;    // const 版本
                            ```
                            
                            - 参数
                                
                                `key`：要查找的键值。
                                
                            - 返回值
                                
                                若键存在：返回指向该键值对的迭代(`iterator` 或 `const_iterator`).
                                
                                若键不存在：返回 `end()` 迭代器，表示查找失败。
                                
                            - 示例代码
                                
                                ```cpp
                                #include <iostream>#include <unordered_map>#include <string>int main() {
                                    std::unordered_map<int, std::string> map = {
                                        {1, "apple"},
                                        {2, "banana"},
                                        {3, "cherry"}
                                    };
                                
                                    // 查找键 2
                                    auto it = map.find(2);
                                    if (it != map.end()) {
                                        std::cout << "Found: " << it->first << " => " << it->second << "\n";
                                    } else {
                                        std::cout << "Key 2 not found.\n";
                                    }
                                
                                    // 查找键 4（不存在）
                                    if (map.find(4) == map.end()) {
                                        std::cout << "Key 4 not found.\n";
                                    }
                                
                                    return 0;
                                }
                                ```
                                
                            - 输出结果:
                                
                                ```
                                Found: 2 => banana
                                Key 4 not found.
                                ```
                                
                        - 迭代器的使用
                            
                            `find()` 返回的迭代器指向一个 `std::pair<const Key, T>`，其中：
                            
                            - `it->first`：键(key)。
                            - `it->second`：值(value)。
                            - 修改值(非 const 版本)
                            
                            ```cpp
                            auto it = map.find(1);
                            if (it != map.end()) {
                                it->second = "avocado";  // 修改键 1 对应的值
                            }
                            ```
                            
                        - 时间复杂度
                            - 平均情况：O (1)。哈希表通过哈希函数直接定位存储位置，通常一次操作即可完成查找。
                            - 最坏情况：O (n)。当发生大量哈希冲突，所有元素聚集在同一个桶中时，需遍历整个桶链表。
                            
                            <aside>
                            ⚠️
                            
                            注意：实际应用中，通过合理设计哈希函数和调整负载因子（Load Factor），可将冲突概率降至极低，因此 `find()` 的性能接近常数时间。
                            
                            </aside>
                            
                        - 与其他容器的 `find()` 对比
                            
                            
                            | 容器 | 底层结构 | `find()` 时间复杂度 | 特点 |
                            | --- | --- | --- | --- |
                            | `unordered_map` | 哈希表 | 平均 O (1)，最坏 O (n) | 无序存储，查找最快 |
                            | `map` | 红黑树（平衡二叉树） | O(log n) | 按键有序，支持范围查找 |
                            | `vector`/`list` | 线性结构 | O(n) | 需遍历全量元素 |
                        - 自定义键类型的查找
                            
                            若键为自定义类型（如结构体或类），需同时提供：
                            
                            - 哈希函数：将键映射为哈希值。
                            - 相等比较函数：判断两个键是否相等。
                            - 示例：自定义 Point 类型作为键
                                
                                ```cpp
                                #include <unordered_map>struct Point {
                                    int x, y;
                                    bool operator==(const Point& other) const {
                                        return x == other.x && y == other.y;
                                    }
                                };
                                
                                // 自定义哈希函数
                                struct PointHash {
                                    size_t operator()(const Point& p) const {
                                        return std::hash<int>()(p.x) ^ (std::hash<int>()(p.y) << 1);
                                    }
                                };
                                
                                // 使用自定义键类型的哈希表
                                std::unordered_map<Point, std::string, PointHash> pointMap;
                                
                                // 插入元素
                                pointMap[{1, 2}] = "坐标 (1,2)";
                                
                                // 查找元素
                                auto it = pointMap.find({1, 2});
                                if (it != pointMap.end()) {
                                    std::cout << "找到点: " << it->second << "\n";
                                }
                                ```
                                
                        - 常见错误与注意事项
                            - 直接解引用 `end()` 迭代器：
                                
                                ```cpp
                                auto it = map.find(4);
                                // std::cout << it->second;  // 错误！若 it == end()，解引用会导致未定义行为
                                ```
                                
                            - 混淆 `find()` 与 `operator[]`：
                                - `find()`：仅查找，不修改容器。
                                - `operator[]`：若键不存在，会插入默认值(可能导致意外行为).
                                    
                                    ```cpp
                                    map[4];  // 即使键 4 不存在，也会插入 {4, ""}
                                    ```
                                    
                            - **性能误区**：
                                - 哈希表的 `find()` 在数据量较大时仍保持 O (1) 复杂度，而 `vector` 的 `std::find()` 为 O (n)，数据量越大差距越明显。
                            
                            <aside>
                            ⚠️
                            
                            ### **总结**
                            
                            - **`u**nordered_map::find()` 是哈希表的核心查找接口，适用于快速判断键是否存在并获取对应值。
                            - 返回值检查：必须通过 `it != map.end()` 判断查找是否成功。
                            - 性能优势：平均 O (1) 的时间复杂度使其成为海量数据下高效查找的首选。
                            - 自定义键类型：需提供哈希函数和相等比较函数，确保哈希表正常工作。
                            </aside>
                            
                    - `count()`：统计键的数量(哈希表中为 0 或 1)。
                    - `at()`：通过键访问值，若键不存在则抛出异常。
                    
                    ```cpp
                    // 查找键 2
                    auto it = map.find(2);
                    if (it != map.end()) {
                        std::cout << "Found: " << it->second << "\n";  // 输出 "cherry"
                    }
                    
                    // 检查键 5 是否存在
                    if (map.count(5) == 0) {
                        std::cout << "Key 5 not found.\n";
                    }
                    
                    // 使用 at() 访问值
                    std::cout << map.at(3) << "\n";     // 输出 "elderberry"
                    // map.at(5);                       // 抛出 std::out_of_range 异常
                    ```
                    
                - 删除元素
                    - `erase()`：删除指定键或迭代器位置的元素。
                    - `clear()`：清空哈希表。
                    
                    ```cpp
                    // 删除键 2
                    map.erase(2);
                    
                    // 使用迭代器删除（删除第一个元素）
                    if (!map.empty()) {
                        map.erase(map.begin());
                    }
                    
                    // 清空哈希表
                    map.clear();
                    ```
                    
            - 容量与状态函数
                - `size()`：返回元素数量。
                - `empty()`：判断是否为空。
                - `max_size()`：返回哈希表支持的最大元素数量。
                
                ```cpp
                bool isEmpty = map.empty();         // true（已清空）
                map.insert({1, "apple"});
                size_t s = map.size();              // 1
                ```
                
            - 迭代器函数
                - `begin()`/`end()`：返回指向起始 / 末尾的迭代器（正向）。
                - `cbegin()`/`cend()`：返回 const 迭代器。
                
                ```cpp
                // 遍历哈希表（顺序不确定，取决于哈希函数）
                for (auto& pair : map) {
                    std::cout << pair.first << ": " << pair.second << "\n";
                }
                
                // 使用迭代器遍历
                for (auto it = map.begin(); it != map.end(); ++it) {
                    std::cout << it->first << ": " << it->second << "\n";
                }
                ```
                
            - 哈希策略函数
                - 哈希表通过调整桶(Bucket)的数量和负载因子(Load Factor)来优化性能：
                - `bucket_count()`：返回当前桶的数量。
                - `load_factor()`：返回负载因子(元素数 / 桶数)。
                - `max_load_factor()`：返回或设置最大负载因子。
                - `rehash()`：重新哈希，设置桶的最小数量。
                - `reserve()`：预留空间，调整桶数以容纳指定数量的元素。
                
                ```cpp
                // 获取当前桶数量和负载因子
                size_t buckets = map.bucket_count();
                float loadFactor = map.load_factor();
                
                // 设置最大负载因子
                map.max_load_factor(0.75f);
                
                // 预留空间，避免频繁 rehash
                map.reserve(1000);  // 预先分配足够的桶，减少哈希冲突
                ```
                
            - 高级操作
                - 检查键是否存在
                
                ```cpp
                if (map.contains(1)) {  // C++20 起支持
                    std::cout << "Key 1 exists.\n";
                }
                ```
                
                - 插入或更新（C++17 起）
                
                ```cpp
                // 若键不存在，插入；否则更新值
                map.insert_or_assign(5, "fig");
                ```
                
                - 提取和合并（C++17 起）
                
                ```cpp
                std::unordered_map<int, std::string> map2;
                map2.insert({6, "grape"});
                
                // 从 map2 提取元素到 map
                map.merge(map2);  // map2 中的元素会被移动到 map
                ```
                
            - 自定义哈希函数
                
                若键为自定义类型，需提供哈希函数和相等比较函数：
                
                ```cpp
                struct Point {
                    int x, y;
                    bool operator==(const Point& other) const {
                        return x == other.x && y == other.y;
                    }
                };
                
                // 自定义哈希函数
                struct PointHash {
                    size_t operator()(const Point& p) const {
                        return std::hash<int>()(p.x) ^ (std::hash<int>()(p.y) << 1);
                    }
                };
                
                // 使用自定义哈希函数的哈希表
                std::unordered_map<Point, std::string, PointHash> pointMap;
                pointMap[{1, 2}] = "origin";
                ```
                
        - 性能考虑
            - 哈希冲突：不同键通过哈希函数映射到同一位置时发生冲突。优秀的哈希函数和足够的桶数量可减少冲突。
            - 负载因子：负载因子过高（如超过 1.0）会增加冲突概率，降低性能。通常当负载因子超过最大负载因子时，哈希表会自动扩容（rehash）。
            - 扩容开销：`rehash()` 会重新分配桶并重新计算所有元素的位置，可能导致性能波动。预先调用 `reserve()` 可避免频繁扩容。
            
            <aside>
            ✅
            
            ## 总结:
            
            | 操作 | 函数 | 时间复杂度 |
            | --- | --- | --- |
            | 插入元素 | `insert()`, `operator[]` | 平均 O (1) |
            | 查找元素 | `find()`, `count()` | 平均 O (1) |
            | 删除元素 | `erase()` | 平均 O (1) |
            | 遍历元素 | `begin()`, `end()` | O(n) |
            | 检查键是否存在 | `find()`, `contains()` | 平均 O (1) |
            </aside>
            
- 串
    - 字符串的基本操作
        - 字符串的创建与初始化
            - **使用构造函数**：
                - `std::string` 提供了多种构造函数来创建字符串。
                    
                    ```cpp
                    #include <iostream>
                    #include <string>int main() 
                    {
                        std::string s1; // 默认构造函数，创建一个空字符串
                        std::string s2("Hello"); // 从 C 风格字符串初始化
                        std::string s3(s2); // 拷贝构造函数
                        std::string s4(5, 'a'); // 创建包含 5 个 'a' 的字符串
                        return 0;
                    }
                    ```
                    
        - 字符串的拼接
            - **使用 `+` 运算符**：可以直接使用 `+` 运算符来拼接两个字符串。
            
            ```cpp
            #include <iostream>
            #include <string>
            int main() {
                std::string s1 = "Hello";
                std::string s2 = " World";
                std::string s3 = s1 + s2;
                std::cout << s3 << std::endl;
                return 0;
            }
            ```
            
            - **使用 `append` 函数**：`append` 函数可以将另一个字符串追加到当前字符串的末尾。
            
            ```cpp
            #include <iostream>
            #include <string>
            int main() {
                std::string s1 = "Hello";
                std::string s2 = " World";
                s1.append(s2);
                std::cout << s1 << std::endl;
                return 0;
            }
            ```
            
            <aside>
            ✅
            
            ### **C++ 字符串拼接方法对比表**
            
            | **对比维度** | `+` 运算符 | `append()` 函数 |
            | --- | --- | --- |
            | **基本语法** | `str3 = str1 + str2;`（支持 `string` 与 `const char*`/`char` 拼接） | `str1.append(str2);`（支持链式调用：`str.append(a).append(b)`） |
            | **返回值** | 返回新字符串对象（原对象不变） | 直接修改原字符串对象（无返回值，但可链式调用） |
            | **内存分配** | 每次拼接创建新对象，可能触发多次内存分配和拷贝 | 直接在原对象末尾追加，可能预分配内存（减少扩容次数） |
            | **性能（少量拼接）** | 简洁直观，适合少量拼接（如 2-3 次） | 代码稍冗长，但效率与 `+` 相近 |
            | **性能（多次拼接）** | 低效（循环中每次创建新对象，时间复杂度 O(n²)） | 高效（内存预分配，时间复杂度 O(n)） |
            | **链式调用** | 不支持 | 支持（如 `str.append("a").append("b")`） |
            | **适用场景** | 简单拼接、代码可读性优先 | 复杂拼接、性能敏感场景（如循环中大量拼接） |
            | **典型代码示例** | `cpp<br>string s = "Hello" + " " + "World";<br>// 生成 "Hello World"` | `cpp<br>string s = "Hello";<br>s.append(" ").append("World");<br>// 生成 "Hello World"` |
            </aside>
            
            - **性能对比示意图**
            
            ```
            +---------------------+---------------------+---------------------+
            | 场景                | + 运算符耗时        | append() 耗时       |
            +---------------------+---------------------+---------------------+
            | 单次拼接            | 低                  | 低                  |
            | 10次循环拼接        | 高（O(n²)）         | 低（O(n)）          |
            | 1000次循环拼接      | 极高（频繁内存分配）| 低（预分配优化）    |                  
            +---------------------+---------------------+---------------------+
            ```
            
    - 字符串的查找与替换
        - 2.1 查找子字符串
            - **使用 `find` 函数**：`find` 函数用于查找子字符串在当前字符串中**第一次**出现的位置，如果找到则返回该位置的索引，否则返回 `std::string::npos`。
            
            ```cpp
            #include <iostream>
            #include <string>
            int main() {
                std::string s = "Hello World";
                size_t pos = s.find("World");
                if (pos != std::string::npos) {
                    std::cout << "Found at position: " << pos << std::endl;
                } else {
                    std::cout << "Not found" << std::endl;
                }
                return 0;
            }
            ```
            
            <aside>
            💡
            
            • **使用 `rfind` 函数**：`rfind` 函数用于查找子字符串在当前字符串中最后一次出现的位置。
            
            </aside>
            
        - 2.2 替换子字符串
            - **使用 `replace` 函数**：`replace` 函数可以将指定位置和长度的子字符串替换为另一个字符串。
                
                ```cpp
                #include <iostream>
                #include <string>
                int main() {
                    std::string s = "Hello World";
                    s.replace(6, 5, "C++");
                    std::cout << s << std::endl;
                    return 0;
                }
                ```
                
    - 字符串的分割
        - **3.1 使用 `std::istringstream`**
            - 可以使用 `std::istringstream` 来分割字符串，通常结合 `getline` 函数使用。
                
                ```cpp
                #include <iostream>
                #include <string>
                #include <sstream>
                #include <vector>
                int main() {
                    std::string s = "Hello,World,How,Are,You";
                    std::istringstream iss(s);
                    std::string token;
                    std::vector<std::string> tokens;
                    while (std::getline(iss, token, ',')) {
                        tokens.push_back(token);
                    }
                    for (const auto& t : tokens) {
                        std::cout << t << std::endl;
                    }
                    return 0;
                }
                ```
                
    - 字符串的大小写转换
        - **4.1 使用 `std::transform` 函数**
            - 可以使用 `std::transform` 函数结合 `std::tolower` 或 `std::toupper` 来进行大小写转换。
                
                ```cpp
                #include <iostream>
                #include <string>
                #include <algorithm>
                int main() {
                    std::string s = "Hello World";
                    std::transform(s.begin(), s.end(), s.begin(), ::tolower);
                    std::cout << s << std::endl;
                    std::transform(s.begin(), s.end(), s.begin(), ::toupper);
                    std::cout << s << std::endl;
                    return 0;
                }
                ```
                
    - 字符串与其他数据类型的转换
        - **5.1 字符串转数字**
            - **使用 `std::stoi`、`std::stol`、`std::stof`、`std::stoll`等函数**：这些函数可以将字符串转换为对应的数字类型。
                
                ```cpp
                #include <iostream>
                #include <string>
                int main() {
                    std::string s = "123";
                    int num = std::stoi(s);
                    std::cout << num << std::endl;
                    return 0;
                }
                ```
                
        - **5.2 数字转字符串**
            - **使用 `std::to_string` 函数**：该函数可以将数字转换为字符串。
                
                ```cpp
                #include <iostream>
                #include <string>
                int main() {
                    int num = 123;
                    std::string s = std::to_string(num);
                    std::cout << s << std::endl;
                    return 0;
                }
                ```
                
    - KMP算法
    - Manacher算法
- 树
    - 线段树
        - 线段树基础
            
            线段树是一种高效处理区间查询和区间更新的数据结构，它通过将区间递归分解为子区间，实现了**O(log n)**时间复杂度的查询与更新操作，广泛应用于区间求和.区间最值.区间修改等场景。
            
            [线段树基础 - OI Wiki](https://oi-wiki.org/ds/seg/#%E5%BC%95%E5%85%A5)
            
            1. 基本概念与结构
                
                线段树是一棵完全二叉树，每个节点对应一个区间，整体用于表示一个原始数组。其结构特点如下：
                
                - 根节点：对应整个数组的区间（如`[1, n]`，假设数组索引从1开始）。
                - 叶子节点：对应数组中的单个元素（如`[i, i]`对应数组第i个元素）。
                - 非叶子节点：对应一个子区间`[l, r]`，其左孩子对应`[l, mid]`，右孩子对应`[mid+1, r]`（其中`mid = (l + r) / 2`）。
                
                通过这种递归划分，线段树能快速定位任意区间的覆盖节点，从而高效处理区间操作。
                
            2. 核心操作
                
                线段树的核心操作包括构建(build)、查询(query)、更新(update)，以下以“区间求和”为例说明。
                
                1. 构建（Build）
                    
                    构建过程从叶子节点开始，递归向上合并左右孩子的信息最终形成整棵树。
                    
                    - 步骤：
                        1. 若当前节点是叶子节点（`l == r`），则节点值为数组对应元素。
                        2. 否则，递归构建左孩子（`[l, mid]`）和右孩子（`[mid+1, r]`），当前节点值为左右孩子值的和.
                    - 时间复杂度：O(n)(总节点数为O(2n)).
                2. 查询（Query）
                    
                    查询区间`[L, R]`的和时，从根节点出发，根据当前节点区间与`[L, R]`的关系处理：
                    
                    - 情况1：当前节点区间完全在`[L, R]`内，直接返回节点值。
                    - 情况2：当前节点区间与`[L, R]`部分重叠，递归查询左右孩子，返回结果之和。
                    - 情况3：当前节点区间与`[L, R]`无重叠，返回0（求和场景）。
                    - 时间复杂度：O(log n)（每次递归将区间缩小一半）。
                3. 单点更新（Update）
                    
                    更新数组中某个位置`i`的值时，从对应叶子节点出发，递归向上更新所有相关父节点的值。
                    
                    - 步骤：
                        1. 若当前节点是叶子节点（`l == r == i`），更新节点值。
                        2. 否则，判断`i`在左孩子还是右孩子区间，递归更新对应孩子，再更新当前节点值（左右孩子之和）。
                    - 时间复杂度：**O(log n)**。
            3. 区间更新与懒惰标记（Lazy Propagation）
                
                当需要对区间`[L, R]`整体更新（如全部加一个值）时，直接更新每个叶子节点效率极低（O(n)）。此时需引入懒惰标记优化：
                
                - 核心思想：对需要更新的区间节点，先记录更新操作（标记），暂不向下传递；当后续查询/更新涉及该节点的子节点时，再将标记下推到孩子节点，确保数据正确性。
                - 步骤：
                    1. 若当前节点区间完全在`[L, R]`内，更新节点值（如加上`k * (r - l + 1)`），并记录懒惰标记（如`add += k`）。
                    2. 若部分重叠，先下推已有标记（若存在），再递归更新左右孩子，最后合并结果。
                    3. 下推标记时，将当前节点的标记传递给左右孩子，更新孩子值和标记，清空当前节点标记。
                - 时间复杂度：O(log n)（标记延迟传递，避免重复操作）。
            4. C++实现示例
                
                以下是支持区间求和、单点更新和区间加更新的线段树实现：
                
                ```cpp
                #include <iostream>
                #include <vector>
                using namespace std;
                
                class SegmentTree {
                private:
                    vector<int> tree;   // 线段树数组
                    vector<int> lazy;   // 懒惰标记数组
                    int n;              // 原始数组长度
                
                    // 构建线段树
                    void build(const vector<int>& arr, int node, int l, int r) {
                        if (l == r) {
                            tree[node] = arr[l];  // 叶子节点赋值
                            return;
                        }
                        int mid = (l + r) / 2;
                        int left = 2 * node;      // 左孩子索引（根为1）
                        int right = 2 * node + 1; // 右孩子索引
                        build(arr, left, l, mid);
                        build(arr, right, mid + 1, r);
                        tree[node] = tree[left] + tree[right]; // 合并左右孩子
                    }
                
                    // 下推懒惰标记
                    void pushDown(int node, int l, int r) {
                        if (lazy[node] == 0) return; // 无标记则无需下推
                        int mid = (l + r) / 2;
                        int left = 2 * node;
                        int right = 2 * node + 1;
                
                        // 更新左孩子
                        tree[left] += lazy[node] * (mid - l + 1);
                        lazy[left] += lazy[node];
                        // 更新右孩子
                        tree[right] += lazy[node] * (r - mid);
                        lazy[right] += lazy[node];
                        // 清空当前节点标记
                        lazy[node] = 0;
                    }
                
                    // 区间加更新（[L, R]加k）
                    void updateRange(int node, int l, int r, int L, int R, int k) {
                        if (L <= l && r <= R) { // 当前区间完全在更新范围内
                            tree[node] += k * (r - l + 1);
                            lazy[node] += k;    // 记录标记
                            return;
                        }
                        pushDown(node, l, r);   // 下推标记
                        int mid = (l + r) / 2;
                        int left = 2 * node;
                        int right = 2 * node + 1;
                        if (L <= mid) updateRange(left, l, mid, L, R, k);
                        if (R > mid) updateRange(right, mid + 1, r, L, R, k);
                        tree[node] = tree[left] + tree[right]; // 合并结果
                    }
                
                    // 单点更新（位置i改为val）
                    void updatePoint(int node, int l, int r, int i, int val) {
                        if (l == r) { // 找到叶子节点
                            tree[node] = val;
                            return;
                        }
                        pushDown(node, l, r); // 下推标记（若有）
                        int mid = (l + r) / 2;
                        int left = 2 * node;
                        int right = 2 * node + 1;
                        if (i <= mid) updatePoint(left, l, mid, i, val);
                        else updatePoint(right, mid + 1, r, i, val);
                        tree[node] = tree[left] + tree[right]; // 合并结果
                    }
                
                    // 区间查询（[L, R]的和）
                    int query(int node, int l, int r, int L, int R) {
                        if (L <= l && r <= R) { // 当前区间完全在查询范围内
                            return tree[node];
                        }
                        pushDown(node, l, r);   // 下推标记（确保子节点数据正确）
                        int mid = (l + r) / 2;
                        int left = 2 * node;
                        int right = 2 * node + 1;
                        int sum = 0;
                        if (L <= mid) sum += query(left, l, mid, L, R);
                        if (R > mid) sum += query(right, mid + 1, r, L, R);
                        return sum;
                    }
                
                public:
                    // 构造函数：根据原始数组初始化线段树
                    SegmentTree(const vector<int>& arr) {
                        n = arr.size() - 1; // 假设arr从索引1开始
                        tree.resize(4 * (n + 1)); // 大小通常为4*n确保足够
                        lazy.resize(4 * (n + 1), 0);
                        build(arr, 1, 1, n); // 根节点索引为1，覆盖区间[1, n]
                    }
                
                    // 公开接口：区间加更新
                    void updateRange(int L, int R, int k) {
                        updateRange(1, 1, n, L, R, k);
                    }
                
                    // 公开接口：单点更新
                    void updatePoint(int i, int val) {
                        updatePoint(1, 1, n, i, val);
                    }
                
                    // 公开接口：区间查询
                    int query(int L, int R) {
                        return query(1, 1, n, L, R);
                    }
                };
                
                // 示例用法
                int main() {
                    vector<int> arr = {0, 1, 3, 5, 7, 9, 11}; // 索引0闲置，从1开始
                    SegmentTree st(arr);
                
                    cout << "查询[2,5]的和：" << st.query(2, 5) << endl; // 3+5+7+9=24
                
                    st.updatePoint(3, 6); // 将位置3的值从5改为6
                    cout << "更新后[2,5]的和：" << st.query(2, 5) << endl; // 3+6+7+9=25
                
                    st.updateRange(2, 4, 2); // 区间[2,4]各元素加2
                    cout << "区间更新后[2,5]的和：" << st.query(2, 5) << endl; // (3+2)+(6+2)+(7+2)+9=5+8+9+9=31
                
                    return 0;
                }
                ```
                
                > OI Wiki上的ST表模板
                > 
                > 
                > [线段树基础 - OI Wiki](https://oi-wiki.org/ds/seg/#c-%E6%A8%A1%E6%9D%BF)
                > 
                > SegTreeLazyRangeAdd 可以区间加/求和的线段树模板:
                > 
                > ```cpp
                > #include <bits/stdc++.h>
                > using namespace std;
                > 
                > template <typename T>
                > class SegTreeLazyRangeAdd {
                >   vector<T> tree, lazy;
                >   vector<T> *arr;
                >   int n, root, n4, end;
                > 
                >   void maintain(int cl, int cr, int p) {
                >     int cm = cl + (cr - cl) / 2;
                >     if (cl != cr && lazy[p]) {
                >       lazy[p * 2] += lazy[p];
                >       lazy[p * 2 + 1] += lazy[p];
                >       tree[p * 2] += lazy[p] * (cm - cl + 1);
                >       tree[p * 2 + 1] += lazy[p] * (cr - cm);
                >       lazy[p] = 0;
                >     }
                >   }
                > 
                >   T range_sum(int l, int r, int cl, int cr, int p) {
                >     if (l <= cl && cr <= r) return tree[p];
                >     int m = cl + (cr - cl) / 2;
                >     T sum = 0;
                >     maintain(cl, cr, p);
                >     if (l <= m) sum += range_sum(l, r, cl, m, p * 2);
                >     if (r > m) sum += range_sum(l, r, m + 1, cr, p * 2 + 1);
                >     return sum;
                >   }
                > 
                >   void range_add(int l, int r, T val, int cl, int cr, int p) {
                >     if (l <= cl && cr <= r) {
                >       lazy[p] += val;
                >       tree[p] += (cr - cl + 1) * val;
                >       return;
                >     }
                >     int m = cl + (cr - cl) / 2;
                >     maintain(cl, cr, p);
                >     if (l <= m) range_add(l, r, val, cl, m, p * 2);
                >     if (r > m) range_add(l, r, val, m + 1, cr, p * 2 + 1);
                >     tree[p] = tree[p * 2] + tree[p * 2 + 1];
                >   }
                > 
                >   void build(int s, int t, int p) {
                >     if (s == t) {
                >       tree[p] = (*arr)[s];
                >       return;
                >     }
                >     int m = s + (t - s) / 2;
                >     build(s, m, p * 2);
                >     build(m + 1, t, p * 2 + 1);
                >     tree[p] = tree[p * 2] + tree[p * 2 + 1];
                >   }
                > 
                >  public:
                >   explicit SegTreeLazyRangeAdd<T>(vector<T> v) {
                >     n = v.size();
                >     n4 = n * 4;
                >     tree = vector<T>(n4, 0);
                >     lazy = vector<T>(n4, 0);
                >     arr = &v;
                >     end = n - 1;
                >     root = 1;
                >     build(0, end, 1);
                >     arr = nullptr;
                >   }
                > 
                >   void show(int p, int depth = 0) {
                >     if (p > n4 || tree[p] == 0) return;
                >     show(p * 2, depth + 1);
                >     for (int i = 0; i < depth; ++i) putchar('\t');
                >     printf("%d:%d\n", tree[p], lazy[p]);
                >     show(p * 2 + 1, depth + 1);
                >   }
                > 
                >   T range_sum(int l, int r) { return range_sum(l, r, 0, end, root); }
                > 
                >   void range_add(int l, int r, T val) { range_add(l, r, val, 0, end, root); }
                > };
                > ```
                > 
                > SegTreeLazyRangeSet 可以区间修改/求和的线段树模板
                > 
                > ```cpp
                > #include <bits/stdc++.h>
                > using namespace std;
                > 
                > template <typename T>
                > class SegTreeLazyRangeSet {
                >   vector<T> tree, lazy;
                >   vector<T> *arr;
                >   vector<bool> ifLazy;
                >   int n, root, n4, end;
                > 
                >   void maintain(int cl, int cr, int p) {
                >     int cm = cl + (cr - cl) / 2;
                >     if (cl != cr && ifLazy[p]) {
                >       lazy[p * 2] = lazy[p], ifLazy[p * 2] = 1;
                >       lazy[p * 2 + 1] = lazy[p], ifLazy[p * 2 + 1] = 1;
                >       tree[p * 2] = lazy[p] * (cm - cl + 1);
                >       tree[p * 2 + 1] = lazy[p] * (cr - cm);
                >       lazy[p] = 0;
                >       ifLazy[p] = 0;
                >     }
                >   }
                > 
                >   T range_sum(int l, int r, int cl, int cr, int p) {
                >     if (l <= cl && cr <= r) return tree[p];
                >     int m = cl + (cr - cl) / 2;
                >     T sum = 0;
                >     maintain(cl, cr, p);
                >     if (l <= m) sum += range_sum(l, r, cl, m, p * 2);
                >     if (r > m) sum += range_sum(l, r, m + 1, cr, p * 2 + 1);
                >     return sum;
                >   }
                > 
                >   void range_set(int l, int r, T val, int cl, int cr, int p) {
                >     if (l <= cl && cr <= r) {
                >       lazy[p] = val;
                >       ifLazy[p] = 1;
                >       tree[p] = (cr - cl + 1) * val;
                >       return;
                >     }
                >     int m = cl + (cr - cl) / 2;
                >     maintain(cl, cr, p);
                >     if (l <= m) range_set(l, r, val, cl, m, p * 2);
                >     if (r > m) range_set(l, r, val, m + 1, cr, p * 2 + 1);
                >     tree[p] = tree[p * 2] + tree[p * 2 + 1];
                >   }
                > 
                >   void build(int s, int t, int p) {
                >     if (s == t) {
                >       tree[p] = (*arr)[s];
                >       return;
                >     }
                >     int m = s + (t - s) / 2;
                >     build(s, m, p * 2);
                >     build(m + 1, t, p * 2 + 1);
                >     tree[p] = tree[p * 2] + tree[p * 2 + 1];
                >   }
                > 
                >  public:
                >   explicit SegTreeLazyRangeSet<T>(vector<T> v) {
                >     n = v.size();
                >     n4 = n * 4;
                >     tree = vector<T>(n4, 0);
                >     lazy = vector<T>(n4, 0);
                >     ifLazy = vector<bool>(n4, 0);
                >     arr = &v;
                >     end = n - 1;
                >     root = 1;
                >     build(0, end, 1);
                >     arr = nullptr;
                >   }
                > 
                >   void show(int p, int depth = 0) {
                >     if (p > n4 || tree[p] == 0) return;
                >     show(p * 2, depth + 1);
                >     for (int i = 0; i < depth; ++i) putchar('\t');
                >     printf("%d:%d\n", tree[p], lazy[p]);
                >     show(p * 2 + 1, depth + 1);
                >   }
                > 
                >   T range_sum(int l, int r) { return range_sum(l, r, 0, end, root); }
                > 
                >   void range_set(int l, int r, T val) { range_set(l, r, val, 0, end, root); }
                > };
                > ```
                > 
            5. 适用场景与对比
                - 适用场景：需要频繁进行区间查询（如求和、最值）和区间更新的场景（如区间增减、区间赋值）。
                - 与树状数组（Fenwick Tree）对比：
                    - 线段树：功能更通用，支持任意区间查询和更新，但实现较复杂。
                    - 树状数组：仅支持前缀相关操作（如前缀和），但实现简单、常数更小。
            
            <aside>
            ✅
            
            ### 总结
            
            线段树通过分治思想将区间操作转化为对数级别的节点操作，配合懒惰标记可高效处理区间更新，是算法竞赛和工程中处理区间问题的核心工具之一。掌握其原理和实现，能显著提升区间操作的效率。
            
            </aside>
            
    - 字典树(trie)
    - Tricks建树(O(n))
        
        在 C++ 中，"Tricks 建树方法" 通常指的是一些在特定场景下优化树结构构建的技巧或特殊方法，这些方法往往针对特定问题（如竞赛题、性能敏感场景）设计，能显著提升效率或简化实现。以下是几种常见的 Tricks 建树方法：
        
        1. 静态数组模拟树（适用于已知规模的场景）
            
            在算法竞赛中，为避免动态内存分配（`new`/`malloc`）的开销，常使用静态数组预先分配内存来模拟树结构。这种方法速度快，且能避免内存碎片。
            
            实现方式：
            
            - 用两个数组分别存储节点的左右子节点（或邻接表存储子节点列表）
            - 用一个指针/索引记录当前已使用的节点数量
            
            示例代码：
            
            ```cpp
            #include <iostream>
            using namespace std;
            
            const int MAX_NODES = 100000; // 预定义最大节点数
            int left_child[MAX_NODES];    // 存储左子节点索引
            int right_child[MAX_NODES];   // 存储右子节点索引
            int value[MAX_NODES];         // 存储节点值
            int node_count = 0;           // 当前节点数量
            
            // 创建新节点
            int create_node(int val) {
                value[node_count] = val;
                left_child[node_count] = -1; // -1 表示无孩子
                right_child[node_count] = -1;
                return node_count++;
            }
            
            // 插入左子节点
            void insert_left(int parent, int val) {
                left_child[parent] = create_node(val);
            }
            
            // 插入右子节点
            void insert_right(int parent, int val) {
                right_child[parent] = create_node(val);
            }
            
            int main() {
                int root = create_node(10);
                insert_left(root, 5);
                insert_right(root, 15);
                // ... 继续构建树
                return 0;
            }
            ```
            
            适用场景：二叉树、森林等结构，且节点数量可预估（如竞赛题中的数据范围）。
            
        2. 父子索引法（适用于完全二叉树）
            
            完全二叉树的节点具有天然的索引规律，可直接通过数组索引计算父子关系，无需额外存储指针。
            
            核心规律：
            
            - 对于索引为 `i` 的节点：
                - 左孩子索引：`2*i + 1`
                - 右孩子索引：`2*i + 2`
                - 父节点索引：`(i-1) / 2`（整数除法）
            
            示例代码：
            
            ```cpp
            #include <iostream>
            #include <vector>
            using namespace std;
            
            vector<int> tree; // 用vector存储完全二叉树
            
            // 插入节点（按层次顺序）
            void insert(int val) {
                tree.push_back(val);
            }
            
            // 获取左孩子
            int left_child(int i) {
                int idx = 2 * i + 1;
                return (idx < tree.size()) ? tree[idx] : -1; // -1 表示不存在
            }
            
            // 获取右孩子
            int right_child(int i) {
                int idx = 2 * i + 2;
                return (idx < tree.size()) ? tree[idx] : -1;
            }
            
            int main() {
                // 构建完全二叉树：
                //       1
                //     /   \\
                //    2     3
                //   / \\   /
                //  4  5  6
                insert(1);
                insert(2);
                insert(3);
                insert(4);
                insert(5);
                insert(6);
            
                cout << "根节点：" << tree[0] << endl;
                cout << "根的左孩子：" << left_child(0) << endl; // 2
                cout << "根的右孩子：" << right_child(0) << endl; // 3
                return 0;
            }
            
            ```
            
            适用场景：堆（大根堆/小根堆）、完全二叉树相关问题（如层次遍历）。
            
        3. 链式前向星（适用于多叉树/图转树）
            
            链式前向星是一种高效的邻接表实现，常用于图的存储，但也可用于多叉树的构建，尤其适合边数多、节点多的场景。
            
            实现方式：
            
            - 用 `head` 数组记录每个节点的第一条边
            - 用 `next` 数组记录同节点的下一条边（类似链表）
            - 用 `to` 数组记录边的指向节点
            
            示例代码：
            
            ```cpp
            #include <iostream>
            using namespace std;
            
            const int MAX_NODES = 100000;
            const int MAX_EDGES = 200000; // 多叉树边数通常为节点数-1
            
            int head[MAX_NODES]; // 每个节点的第一条边索引
            int to[MAX_EDGES];   // 边指向的节点
            int next_[MAX_EDGES];// 下一条边的索引
            int edge_count = 0;  // 边的数量
            
            // 添加一条从 u 到 v 的边（u 是父节点，v 是子节点）
            void add_edge(int u, int v) {
                to[edge_count] = v;          // 当前边指向 v
                next_[edge_count] = head[u]; // 链接到 u 的上一条边
                head[u] = edge_count++;      // 更新 u 的第一条边为当前边
            }
            
            // 遍历 u 的所有子节点
            void traverse_children(int u) {
                for (int i = head[u]; i != -1; i = next_[i]) {
                    int v = to[i];
                    cout << "子节点：" << v << endl;
                }
            }
            
            int main() {
                // 初始化 head 为 -1（表示无关联边）
                fill(head, head + MAX_NODES, -1);
            
                // 构建多叉树：
                //   0 是根节点
                //   0 的子节点：1, 2
                //   1 的子节点：3, 4
                add_edge(0, 1);
                add_edge(0, 2);
                add_edge(1, 3);
                add_edge(1, 4);
            
                cout << "0 的子节点：" << endl;
                traverse_children(0); // 输出 2, 1（注意顺序与插入相反，可反转调整）
                return 0;
            }
            ```
            
            适用场景：多叉树、树的深度/广度优先遍历、图论中树的构建（如最小生成树）。
            
        4. 笛卡尔树（结合二叉搜索树与堆的特性）
            
            笛卡尔树是一种特殊的二叉树，其节点值满足堆的性质（如父节点值小于所有子节点），且中序遍历结果为原序列顺序。常用于范围查询问题（如 RMQ 区间最值）。
            
            构建方法：
            
            - 以序列中最小值（或最大值）为根
            - 根左侧的元素构成左子树，右侧构成右子树
            - 递归构建左右子树
            
            示例代码：
            
            ```cpp
            #include <iostream>
            #include <vector>
            #include <stack>
            using namespace std;
            
            struct Node {
                int val;
                Node *left, *right;
                Node(int v) : val(v), left(nullptr), right(nullptr) {}
            };
            
            // 单调栈优化构建笛卡尔树（O(n) 时间复杂度）
            Node* build_cartesian_tree(const vector<int>& arr) {
                stack<Node*> stk;
                Node* root = nullptr;
            
                for (int num : arr) {
                    Node* node = new Node(num);
                    Node* last = nullptr;
            
                    // 弹出栈中比当前节点大的元素（保证堆性质）
                    while (!stk.empty() && stk.top()->val > num) {
                        last = stk.top();
                        stk.pop();
                    }
            
                    // 最后弹出的节点作为当前节点的左孩子
                    node->left = last;
            
                    // 栈顶节点的右孩子设为当前节点
                    if (!stk.empty()) {
                        stk.top()->right = node;
                    } else {
                        root = node; // 栈为空时，当前节点为根
                    }
            
                    stk.push(node);
                }
            
                return root;
            }
            
            // 中序遍历（验证是否与原序列一致）
            void inorder(Node* node) {
                if (!node) return;
                inorder(node->left);
                cout << node->val << " ";
                inorder(node->right);
            }
            
            int main() {
                vector<int> arr = {3, 1, 2, 4, 0};
                Node* root = build_cartesian_tree(arr);
                inorder(root); // 输出：3 1 2 4 0（与原序列一致）
                return 0;
            }
            ```
            
            适用场景：区间最值查询（RMQ）、范围拓扑排序等。
            
        5. 线段树/树状数组的隐性建树（功能性树结构）
            
            线段树和树状数组（Fenwick Tree）是用于高效处理区间查询和更新的功能性数据结构，其“树结构”通常通过数组隐性表示，而非显式存储节点指针。
            
            线段树的隐性表示：
            
            - 用数组 `tree` 存储节点值，根节点为 `tree[1]`
            - 左孩子：`2*i`，右孩子：`2*i+1`
            - 无需显式构建树，通过递归或迭代直接操作数组
            
            示例（线段树区间和）：
            
            ```cpp
            #include <vector>
            using namespace std;
            
            vector<int> tree; // 线段树数组
            int n; // 原数组长度
            
            // 构建线段树
            void build(const vector<int>& arr, int node, int start, int end) {
                if (start == end) {
                    tree[node] = arr[start];
                } else {
                    int mid = (start + end) / 2;
                    build(arr, 2*node, start, mid);       // 左子树
                    build(arr, 2*node+1, mid+1, end);     // 右子树
                    tree[node] = tree[2*node] + tree[2*node+1]; // 父节点值为子节点和
                }
            }
            
            // 初始化（需预先分配 tree 大小，通常为 4*n）
            void init(const vector<int>& arr) {
                n = arr.size();
                tree.resize(4 * n);
                build(arr, 1, 0, n-1);
            }
            
            ```
            
            适用场景：区间查询（求和、最值、gcd 等）、动态更新问题。
            
        
        <aside>
        ✅
        
        ### 总结
        
        C++ 中的 Tricks 建树方法本质上是根据问题特性选择的优化策略，核心目标是：
        
        - 减少内存开销（静态数组替代动态分配）
        - 提升效率（隐性结构、单调栈优化）
        - 简化实现（父子索引、链式前向星）
        
        选择哪种方法需结合具体场景，例如：
        
        - 竞赛题优先考虑静态数组或链式前向星
        - 完全二叉树问题优先用父子索引法
        - 区间查询问题优先用线段树/树状数组
        - 序列相关的最值问题可考虑笛卡尔树
        </aside>
        
- 图
- 并查集
    
    并查集（Union-Find）是一种用于高效处理不相交集合的合并与查询问题的数据结构，核心操作是查找（Find）和合并（Union）。它通过树形结构表示集合，每个节点维护一个父指针，根节点的父指针指向自身。
    
    ### 一、核心组成部分
    
    1. 数据结构
        
        并查集的基础实现使用两个数组：`parent` 存储父节点，`rank` 存储树的高度（秩）以优化合并操作。
        
        ```cpp
        class UnionFind {
        private:
            std::vector<int> parent;  // 父节点数组
            std::vector<int> rank;    // 树的秩（高度）
        };
        ```
        
    2. 初始化（Constructor）
        
        创建并查集时，每个元素的父节点初始化为自身，秩初始为1。
        
        ```cpp
        UnionFind(int n) : parent(n), rank(n, 1) {
            for (int i = 0; i < n; ++i) {
                parent[i] = i;  // 初始时每个元素独立成集合
            }
        }
        ```
        
    3. 查找操作（Find）
        
        查找元素所在集合的根节点，并通过路径压缩优化后续查询效率。
        
        ```cpp
        int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]);  // 路径压缩：直接连接到根
            }
            return parent[x];
        }
        ```
        
    4. 合并操作（Union）
        
        将两个元素所在的集合合并为一个，通过按秩合并确保树的平衡性。
        
        ```cpp
        void unionSets(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            if (rootX == rootY) return;  // 已在同一集合
        
            if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;  // 小树并入大树
            } else if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else {
                parent[rootY] = rootX;
                rank[rootX]++;  // 秩相同，合并后秩加1
            }
        }
        ```
        
    5. 连通性判断（Connected）
        
        判断两个元素是否属于同一集合，只需比较它们的根节点是否相同。
        
        ```cpp
        bool connected(int x, int y) {
            return find(x) == find(y);  // 根节点相同则连通
        }
        ```
        
    
    ### 二、优化策略
    
    1. 路径压缩（Path Compression）
        
        在查找过程中，将路径上所有节点直接连接到根节点，使后续查询时间接近 $O(1)$。
        
        ```cpp
        int find(int x) {
            int root = x;
            while (parent[root] != root) {
                root = parent[root];  // 找到根节点
            }
            // 路径压缩：将路径上所有节点直接连接到根
            while (x != root) {
                int next = parent[x];
                parent[x] = root;
                x = next;
            }
            return root;
        }
        ```
        
    2. 按秩合并（Union by Rank）
        
        合并时选择秩较大的树作为根，避免树退化为链表，保证树的高度始终不超过 $O(\log n)$。
        
        ```cpp
        void unionSets(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            if (rootX == rootY) return;
        
            // 按秩合并：小树并入大树
            if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else {
                parent[rootY] = rootX;
                if (rank[rootX] == rank[rootY]) {
                    rank[rootX]++;  // 秩相同，合并后秩加1
                }
            }
        }
        ```
        
    
    ### 三、整体工作流程
    
    以下是完整的并查集实现，包含初始化、查找、合并和连通性判断功能：
    
    ```cpp
    #include <vector>
    
    class UnionFind {
    private:
        std::vector<int> parent;  // 父节点数组
        std::vector<int> rank;    // 树的秩（高度）
    
    public:
        // 初始化
        UnionFind(int n) : parent(n), rank(n, 1) {
            for (int i = 0; i < n; ++i) {
                parent[i] = i;
            }
        }
    
        // 查找（带路径压缩）
        int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]);
            }
            return parent[x];
        }
    
        // 合并（按秩合并）
        void unionSets(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            if (rootX == rootY) return;
    
            if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else {
                parent[rootY] = rootX;
                if (rank[rootX] == rank[rootY]) {
                    rank[rootX]++;
                }
            }
        }
    
        // 判断连通性
        bool connected(int x, int y) {
            return find(x) == find(y);
        }
    };
    
    ```
    
    ### 四、应用场景
    
    1. 连通性问题
        
        判断两点是否连通，并计算连通分量数目。
        
        ```cpp
        // 判断两点是否连通
        bool areConnected(int x, int y, UnionFind& uf) {
            return uf.connected(x, y);
        }
        
        // 计算连通分量数目
        int countComponents(int n, std::vector<std::pair<int, int>>& edges) {
            UnionFind uf(n);
            for (auto& edge : edges) {
                uf.unionSets(edge.first, edge.second);
            }
        
            int count = 0;
            for (int i = 0; i < n; ++i) {
                if (uf.find(i) == i) {
                    count++;  // 统计根节点数量
                }
            }
            return count;
        }
        ```
        
    2. 最小生成树（Kruskal算法）
        
        通过并查集快速检测环，构建最小生成树。
        
        ```cpp
        #include <algorithm>
        
        struct Edge {
            int u, v, weight;
            bool operator<(const Edge& other) const {
                return weight < other.weight;
            }
        };
        
        int kruskal(int n, std::vector<Edge>& edges) {
            std::sort(edges.begin(), edges.end());  // 按边权排序
            UnionFind uf(n);
            int mstWeight = 0;
            int edgeCount = 0;
        
            for (auto& edge : edges) {
                if (!uf.connected(edge.u, edge.v)) {
                    uf.unionSets(edge.u, edge.v);
                    mstWeight += edge.weight;
                    edgeCount++;
                    if (edgeCount == n - 1) break;  // 已找到n-1条边
                }
            }
            return mstWeight;
        }
        ```
        
    
    ### 五、扩展功能
    
    1. 统计集合数目
        
        统计并查集中根节点的数量，即集合数目。
        
        ```cpp
        int getSetCount() {
            int count = 0;
            for (int i = 0; i < parent.size(); ++i) {
                if (parent[i] == i) {
                    count++;  // 根节点数量即集合数目
                }
            }
            return count;
        }
        ```
        
    2. 支持泛型
        
        使用模板实现支持任意数据类型的并查集。
        
        ```cpp
        #include <unordered_map>
        
        template<typename T>
        class UnionFind {
        private:
            std::unordered_map<T, T> parent;
            std::unordered_map<T, int> rank;
        
        public:
            void add(const T& x) {
                if (parent.find(x) == parent.end()) {
                    parent[x] = x;
                    rank[x] = 1;
                }
            }
        
            T find(const T& x) {
                if (parent[x] != x) {
                    parent[x] = find(parent[x]);
                }
                return parent[x];
            }
        
            void unionSets(const T& x, const T& y) {
                add(x);
                add(y);
                T rootX = find(x);
                T rootY = find(y);
                if (rootX == rootY) return;
        
                if (rank[rootX] < rank[rootY]) {
                    parent[rootX] = rootY;
                } else {
                    parent[rootY] = rootX;
                    if (rank[rootX] == rank[rootY]) {
                        rank[rootX]++;
                    }
                }
            }
        };
        ```
        
    3. 维护集合大小
        
        在合并过程中维护每个集合的元素数量。
        
        ```cpp
        class UnionFind {
        private:
            std::vector<int> parent;
            std::vector<int> size;    // 记录集合大小
        
        public:
            UnionFind(int n) : parent(n), size(n, 1) {
                for (int i = 0; i < n; ++i) {
                    parent[i] = i;
                }
            }
        
            int find(int x) {
                if (parent[x] != x) {
                    parent[x] = find(parent[x]);
                }
                return parent[x];
            }
        
            void unionSets(int x, int y) {
                int rootX = find(x);
                int rootY = find(y);
                if (rootX == rootY) return;
        
                // 将较小集合合并到较大集合
                if (size[rootX] < size[rootY]) {
                    parent[rootX] = rootY;
                    size[rootY] += size[rootX];
                } else {
                    parent[rootY] = rootX;
                    size[rootX] += size[rootY];
                }
            }
        
            int getSize(int x) {
                return size[find(x)];  // 返回集合大小
            }
        };
        ```
        
    
    ### 六、测试示例
    
    以下是一个简单的测试示例，演示并查集的基本用法：
    
    ```cpp
    #include <iostream>
    
    int main() {
        UnionFind uf(5);  // 初始化5个元素
    
        // 合并集合
        uf.unionSets(0, 1);
        uf.unionSets(2, 3);
        uf.unionSets(3, 4);
    
        // 查询连通性
        std::cout << "0 和 1 是否连通? " << (uf.connected(0, 1) ? "是" : "否") << std::endl;  // 是
        std::cout << "0 和 4 是否连通? " << (uf.connected(0, 4) ? "是" : "否") << std::endl;  // 否
    
        // 合并更多集合
        uf.unionSets(1, 3);
        std::cout << "0 和 4 是否连通? " << (uf.connected(0, 4) ? "是" : "否") << std::endl;  // 是
    
        return 0;
    }
    ```
    
    <aside>
    ✅
    
    ### 总结
    
    并查集通过树形结构和路径压缩、按秩合并两大优化，高效解决了动态连通性问题。其核心优势在于：
    
    - 时间效率极高：单次操作接近常数时间。
    - 实现简单：核心代码仅需几十行。
    - 扩展性强：可灵活添加统计、泛型、带权等功能。
    </aside>
    
- ST表
    
    在C/C++中，ST表（Sparse Table） 是一种基于倍增思想的高效数据结构，主要用于解决静态区间最值查询（RMQ，Range Minimum/Maximum Query） 问题。它的核心优势是：预处理**时间复杂度为O(nlogn)**，**单次查询时间复杂度为O(1)**，非常适合需要对**静态数据**（不支持修改）进行多次区间最值查询的场景。
    
    [ST 表 - OI Wiki](https://oi-wiki.org/ds/sparse-table/)
    
    1. ST表的核心思想
        
        ST表的设计基于两个关键概念：倍增思想和动态规划（DP）。
        
        1. 倍增思想
            
            倍增思想的核心是“以2的幂次为单位拆解问题”。对于一个长度为`n`的数组，我们不直接处理任意长度的区间，而是预先计算并存储所有长度为`2^k`（`k≥0`）的区间的最值。查询时，通过组合两个长度为`2^k`的区间，覆盖目标区间，从而快速得到结果。
            
        2. 动态规划（DP）定义
            
            ST表用二维数组`dp[k][i]`存储状态，其中：
            
            - `k`表示“区间长度为`2^k`”（即区间长度是2的k次幂）；
            - `i`表示“区间的起始位置”；
            - `dp[k][i]`表示“从位置`i`开始，长度为`2^k`的区间内的最值（最大值或最小值）”。
    2. ST表的构建（预处理）
        
        预处理的目标是填充`dp`数组，步骤如下：
        
        1. 初始化`dp[0][i]`
            
            当`k=0`时，区间长度为`2^0=1`，即单个元素。因此：
            
            `dp[0][i] = a[i]`（`a`为原始数组，`i`为数组下标）。
            
        2. 状态转移方程
            
            对于`k≥1`，长度为`2^k`的区间可以拆分为两个长度为`2^(k-1)`的子区间：
            
            - 第一个子区间：从`i`开始，长度`2^(k-1)`，即`dp[k-1][i]`；
            - 第二个子区间：从`i + 2^(k-1)`开始，长度`2^(k-1)`，即`dp[k-1][i + 2^(k-1)]`。
            
            因此，状态转移方程为：
            
            ```cpp
            // 求最大值时
            dp[k][i] = max(dp[k-1][i], dp[k-1][i + (1 << (k-1))]);
            // 求最小值时
            dp[k][i] = min(dp[k-1][i], dp[k-1][i + (1 << (k-1))]);
            ```
            
            其中`1 << (k-1)`等价于`2^(k-1)`（位运算效率更高）。
            
        3. 预处理`log`数组（优化查询）
            
            查询时需要知道“不超过区间长度的最大2的幂次”，即`k = log2(len)`（`len`为查询区间的长度）。为了避免每次查询时计算`log2`（耗时），可以预先计算一个`log`数组：
            
            `log[i]`表示“最大的`k`使得`2^k ≤ i`”。
            
            `log`数组的预处理代码（C++）：
            
            ```cpp
            int log[MAXN];
            void prelog(int n) {
                log[1] = 0;
                for (int i = 2; i <= n; i++) {
                    log[i] = log[i/2] + 1; // 利用整数除法特性递推
                }
            }
            ```
            
        4. 预处理`dp`数组的完整步骤
            
            假设原始数组`a`的长度为`n`，预处理流程：
            
            1. 初始化`dp[0][i] = a[i]`（`0 ≤ i < n`）；
            2. 计算`log`数组（长度为`n+1`）；
            3. 对`k`从1到`log[n]`（最大可能的`k`），依次计算`dp[k][i]`：
                - 对于每个`i`，需保证`i + 2^k - 1 < n`（区间不越界），即`i ≤ n - (1 << k)`。
    3. ST表的查询操作
        
        对于查询区间`[l, r]`（0-based下标），步骤如下：
        
        1. 计算区间长度`len = r - l + 1`；
        2. 计算`k = log[len]`（最大的`k`使得`2^k ≤ len`）；
        3. 目标区间`[l, r]`可被两个长度为`2^k`的区间覆盖：
            - 第一个区间：`[l, l + 2^k - 1]`，对应`dp[k][l]`；
            - 第二个区间：`[r - 2^k + 1, r]`，对应`dp[k][r - (1 << k) + 1]`；
        4. 区间`[l, r]`的最值为两个区间最值的结果（`max`或`min`）。
        
        <aside>
        ✅
        
        ### 示例
        
        假设原始数组`a = [1, 3, 5, 7, 9, 2, 4]`，查询`[1, 5]`（即元素`3,5,7,9,2`）的最大值：
        
        - `len = 5`，`log[5] = 2`（`2^2=4 ≤ 5`）；
        - 第一个区间：`[1, 1+4-1] = [1,4]`（元素`3,5,7,9`），最大值为`9`；
        - 第二个区间：`[5-4+1,5] = [2,5]`（元素`5,7,9,2`），最大值为`9`；
        - 最终结果：`max(9,9) = 9`（正确，原区间最大值为9）。
        </aside>
        
    4. ST表的实现（C++代码示例）
        
        以下是一个求区间最大值的ST表实现：
        
        ```cpp
        #include <iostream>
        #include <vector>
        #include <cmath>
        using namespace std;
        
        const int MAXN = 1e5 + 5; // 根据实际需求调整
        const int LOG = 20; // 2^20 ≈ 1e6，足够覆盖1e5
        
        int a[MAXN];
        int dp[LOG][MAXN];
        int log_table[MAXN];
        
        // 预处理log表
        void pre_log(int n) {
            log_table[1] = 0;
            for (int i = 2; i <= n; i++) {
                log_table[i] = log_table[i / 2] + 1;
            }
        }
        
        // 预处理ST表（最大值）
        void build_st(int n) {
            // 初始化k=0
            for (int i = 0; i < n; i++) {
                dp[0][i] = a[i];
            }
            // 填充k≥1的情况
            int max_k = log_table[n] + 1;
            for (int k = 1; k < max_k; k++) {
                for (int i = 0; i + (1 << k) <= n; i++) { // 确保区间不越界
                    dp[k][i] = max(dp[k-1][i], dp[k-1][i + (1 << (k-1))]);
                }
            }
        }
        
        // 查询区间[l, r]的最大值（0-based）
        int query_max(int l, int r) {
            int len = r - l + 1;
            int k = log_table[len];
            return max(dp[k][l], dp[k][r - (1 << k) + 1]);
        }
        
        int main() {
            int n, q;
            cin >> n >> q;
            for (int i = 0; i < n; i++) {
                cin >> a[i];
            }
            pre_log(n);
            build_st(n);
            while (q--) {
                int l, r;
                cin >> l >> r;
                l--; r--; // 转为0-based
                cout << query_max(l, r) << endl;
            }
            return 0;
        }
        ```
        
        > OI Wiki上的ST表模板
        > 
        > 
        > ```c
        > #include <algorithm>
        > #include <iostream>
        > using namespace std;
        > constexpr int MAXN = 2000001;
        > constexpr int logN = 21;
        > int f[MAXN][logN + 1], Logn[MAXN + 1];
        > 
        > void pre() {  // 准备工作，初始化
        >   Logn[1] = 0;
        >   Logn[2] = 1;
        >   for (int i = 3; i < MAXN; i++) {
        >     Logn[i] = Logn[i / 2] + 1;
        >   }
        > }
        > 
        > int main() {
        >   cin.tie(nullptr)->sync_with_stdio(false);
        >   int n, m;
        >   cin >> n >> m;
        >   for (int i = 1; i <= n; i++) cin >> f[i][0];
        >   pre();
        >   for (int j = 1; j <= logN; j++)
        >     for (int i = 1; i + (1 << j) - 1 <= n; i++)
        >       f[i][j] = max(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);  // ST表具体实现
        >   for (int i = 1; i <= m; i++) {
        >     int x, y;
        >     cin >> x >> y;
        >     int s = Logn[y - x + 1];
        >     cout << max(f[x][s], f[y - (1 << s) + 1][s]) << '\n';
        >   }
        >   return 0;
        > }
        > ```
        > 
        > [ST 表 - OI Wiki](https://oi-wiki.org/ds/sparse-table/#%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81)
        > 
        > ```cpp
        > #include <algorithm>
        > #include <iostream>
        > using namespace std;
        > constexpr int MAXN = 2000001;
        > constexpr int logN = 21;
        > int f[MAXN][logN + 1], Logn[MAXN + 1];
        > 
        > void pre() {  // 准备工作，初始化
        >   Logn[1] = 0;
        >   Logn[2] = 1;
        >   for (int i = 3; i < MAXN; i++) {
        >     Logn[i] = Logn[i / 2] + 1;
        >   }
        > }
        > 
        > int main() {
        >   cin.tie(nullptr)->sync_with_stdio(false);
        >   int n, m;
        >   cin >> n >> m;
        >   for (int i = 1; i <= n; i++) cin >> f[i][0];
        >   pre();
        >   for (int j = 1; j <= logN; j++)
        >     for (int i = 1; i + (1 << j) - 1 <= n; i++)
        >       f[i][j] = max(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);  // ST表具体实现
        >   for (int i = 1; i <= m; i++) {
        >     int x, y;
        >     cin >> x >> y;
        >     int s = Logn[y - x + 1];
        >     cout << max(f[x][s], f[y - (1 << s) + 1][s]) << '\n';
        >   }
        >   return 0;
        > }
        > ```
        > 
    5. ST表的优缺点
        - 优点
            1. 查询效率极高：单次查询O(1)，远超线段树的O(logn)；
            2. 预处理简单：基于DP和倍增，实现难度低于线段树；
            3. 空间可控：空间复杂度O(nlogn)，对于`n=1e5`，`log n≈17`，空间约为`1e5×17=1.7e6`，完全可接受。
        - 缺点
            1. 不支持动态修改：ST表是为静态数据设计的，若数组元素被修改，整个ST表需要重新构建（复杂度O(nlogn)），实用性低；
            2. 仅支持**最值查询**：无法直接扩展到区间和、区间gcd等其他查询（需结合其他思想）。
    6. 应用场景
        
        ST表主要用于静态区间的最值查询，常见场景包括：
        
        - 算法竞赛中的RMQ问题（如区间最大/最小值查询）；
        - 数据固定不变，需要高频次查询区间最值的场景（如日志分析、静态数据统计）。
    7. 与其他数据结构的对比
        
        
        | 数据结构 | 预处理时间 | 查询时间 | 支持修改 | 适用场景 |
        | --- | --- | --- | --- | --- |
        | ST表 | O(n log n) | O(1) | 不支持 | 静态区间最值 |
        | 线段树 | O(n) | O(log n) | 支持 | 动态区间查询（最值、和等） |
        | 稀疏表 | 同ST表 | 同ST表 | 同ST表 | 同ST表（ST表是稀疏表的一种） |
    
    <aside>
    ✅
    
    总结：ST表是处理静态区间最值查询的“利器”，在算法竞赛和工程中均有广泛应用，但其局限性（不支持修改）也需注意。
    
    </aside>
    
- 树状数组
    - 一维树状数组
        
        在C++中，树状数组（Fenwick Tree）是一种高效的数据结构，主要用于解决数组的前缀和查询以及单点更新问题。它的时间复杂度为O(log n)，相比前缀和数组（更新O(n)）和线段树（实现复杂）具有明显优势。
        
        [树状数组 - OI Wiki](https://oi-wiki.org/ds/fenwick/)
        
        1. 树状数组的基本原理
            
            树状数组通过将数组元素按照二进制表示进行分层存储，形成一个树形结构，从而实现高效的前缀和计算和单点更新。它的核心思想是：
            
            - 每个节点负责存储一定范围的元素和
            - 利用二进制的特性快速定位需要更新或查询的节点
            
            > OI-WIKI中关于树状数组的基础介绍
            > 
            > 
            > ![image.png](%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2025-08-18_215749.png)
            > 
        2. 树状数组的核心操作
            1. lowbit操作：获取一个数二进制表示中最低位的1及其后面的0组成的数
                
                ```cpp
                int lowbit(int x) {
                    return x & -x;
                }
                ```
                
                > OI-WIKI中对OI-WIKI的解释
                > 
                > 
                > ![image.png](%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image.png)
                > 
            2. 单点更新：在指定位置增加一个值
                
                ```cpp
                void update(int idx, int val) {
                    while (idx <= n) {
                        tree[idx] += val;
                        idx += lowbit(idx);
                    }
                }
                ```
                
                > OI-WIKI中的解释
                > 
                > 
                > ![image.png](%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image%201.png)
                > 
            3. 前缀和查询：查询从第一个元素到指定位置的和
                
                ```cpp
                int query(int idx) {
                    int sum = 0;
                    while (idx > 0) {
                        sum += tree[idx];
                        idx -= lowbit(idx);
                    }
                    return sum;
                }
                ```
                
                > OI-WIKI中的解释
                > 
                > 
                > ![image.png](%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image%202.png)
                > 
            4. 区间查询：查询两个位置之间的元素和
                
                ```cpp
                int rangeQuery(int l, int r) {
                    return query(r) - query(l - 1);
                }
                ```
                
        3. 完整实现示例
            
            ```cpp
            #include <iostream>
            #include <vector>
            
            using namespace std;
            
            class FenwickTree {
            private:
                vector<int> tree;  // 树状数组
                int n;             // 数组大小
            
                // 获取最低位的1
                int lowbit(int x) {
                    return x & -x;
                }
            
            public:
                // 构造函数，初始化树状数组
                FenwickTree(int size) : n(size), tree(size + 1, 0) {}
            
                // 从原始数组初始化
                FenwickTree(const vector<int>& arr) {
                    n = arr.size();
                    tree.resize(n + 1, 0);
                    for (int i = 0; i < n; ++i) {
                        update(i + 1, arr[i]);  // 注意：树状数组通常从1开始索引
                    }
                }
            
                // 单点更新：在索引idx处增加val（idx从1开始）
                void update(int idx, int val) {
                    if (idx < 1 || idx > n) return;  // 检查索引合法性
                    while (idx <= n) {
                        tree[idx] += val;
                        idx += lowbit(idx);
                    }
                }
            
                // 前缀和查询：查询[1, idx]的和（idx从1开始）
                int query(int idx) {
                    if (idx < 1 || idx > n) return 0;  // 检查索引合法性
                    int sum = 0;
                    while (idx > 0) {
                        sum += tree[idx];
                        idx -= lowbit(idx);
                    }
                    return sum;
                }
            
                // 区间查询：查询[l, r]的和（l, r从1开始）
                int rangeQuery(int l, int r) {
                    if (l < 1 || r > n || l > r) return 0;  // 检查索引合法性
                    return query(r) - query(l - 1);
                }
            
                // 获取树状数组大小
                int size() const {
                    return n;
                }
            
                // 打印树状数组（用于调试）
                void print() const {
                    cout << "Fenwick Tree: ";
                    for (int i = 1; i <= n; ++i) {
                        cout << tree[i] << " ";
                    }
                    cout << endl;
                }
            };
            
            // 示例用法
            int main() {
                // 示例1：从大小初始化
                FenwickTree ft1(5);
                ft1.update(1, 1);
                ft1.update(2, 2);
                ft1.update(3, 3);
                ft1.update(4, 4);
                ft1.update(5, 5);
                ft1.print();
                cout << "前缀和查询(3): " << ft1.query(3) << endl;  // 1+2+3=6
                cout << "区间查询(2,4): " << ft1.rangeQuery(2, 4) << endl;  // 2+3+4=9
            
                // 示例2：从已有数组初始化
                vector<int> arr = {10, 20, 30, 40, 50};
                FenwickTree ft2(arr);
                ft2.print();
                cout << "前缀和查询(5): " << ft2.query(5) << endl;  // 10+20+30+40+50=150
                ft2.update(3, 5);  // 第三个元素增加5
                cout << "更新后前缀和查询(5): " << ft2.query(5) << endl;  // 150+5=155
                cout << "更新后区间查询(2,4): " << ft2.rangeQuery(2, 4) << endl;  // 20+35+40=95
            
                return 0;
            }
            ```
            
            ---
            
            > OI-WIKI中的写法
            > 
            > 
            > ```cpp
            > int t1[MAXN], t2[MAXN], n;
            > 
            > int lowbit(int x) { return x & (-x); }
            > 
            > void add(int k, int v) {
            >   int v1 = k * v;
            >   while (k <= n) {
            >     t1[k] += v, t2[k] += v1;
            >     // 注意不能写成 t2[k] += k * v，因为 k 的值已经不是原数组的下标了
            >     k += lowbit(k);
            >   }
            > }
            > 
            > int getsum(int *t, int k) {
            >   int ret = 0;
            >   while (k) {
            >     ret += t[k];
            >     k -= lowbit(k);
            >   }
            >   return ret;
            > }
            > 
            > void add1(int l, int r, int v) {
            >   add(l, v), add(r + 1, -v);  // 将区间加差分为两个前缀加
            > }
            > 
            > long long getsum1(int l, int r) {
            >   return (r + 1ll) * getsum(t1, r) - 1ll * l * getsum(t1, l - 1) -
            >          (getsum(t2, r) - getsum(t2, l - 1));
            > }
            > ```
            > 
        4. 树状数组的应用场景
            1. 频率统计：统计元素出现次数并快速查询前缀频率
            2. 逆序对计数：在排序过程中高效计算逆序对数量
            3. 范围更新与范围查询：通过两个树状数组的组合实现
            4. 多维树状数组：处理高维空间中的前缀和问题
        
        <aside>
        💡
        
        ### 树状数组与其他数据结构的比较
        
        | 数据结构 | 单点更新 | 前缀和查询 | 实现复杂度 | 适用场景 |
        | --- | --- | --- | --- | --- |
        | 普通数组 | O(1) | O(n) | 简单 | 适用于更新频繁，查询少的场景 |
        | 前缀和数组 | O(n) | O(1) | 简单 | 适用于查询频繁，更新少的场景 |
        | 树状数组 | O(log n) | O(log n) | 中等 | 平衡更新和查询操作的场景 |
        | 线段树 | O(log n) | O(log n) | 复杂 | 需要支持更多操作（如区间更新）的场景 |
        </aside>
        
    - 二维树状数组
        - 二维树状数组(单点修改,范围查询)
            1. 数据结构本质与设计背景
                1. 定义
                    
                    二维树状数组是一种基于二进制分解的二维前缀和优化结构，专门用于解决「二维数组单点更新」与「矩形区域和查询」的高效处理问题。
                    
                2. 诞生原因
                    - 原始二维数组：查询矩形和需O(nm)时间，效率极低
                    - 二维前缀和数组：更新操作需O(nm)时间，不适合动态场景
                    - 二维树状数组：将两者的时间复杂度均优化至O(logn·logm)，兼顾动态更新与查询效率
            2. 核心原理与数学基础
                1. lowbit运算（核心工具）
                    - 定义：`lowbit(x) = x & -x`（取x二进制中最低位1对应的数值）
                    - 示例：`lowbit(6) = 6 & (-6) = 110 & 010 = 010 = 2lowbit(5) = 5 & (-5) = 101 & 011 = 001 = 1`
                    - 作用：通过二进制分解，将二维空间划分为多个可管理的子矩形
                2. 节点管辖范围
                    
                    对于树状数组中的节点`tree[i][j]`，其管辖的矩形区域为：
                    
                    - 行范围：`[i - lowbit(i) + 1, i]`
                    - 列范围：`[j - lowbit(j) + 1, j]`
                    - 示例：`i=6`（二进制110）、`j=5`（二进制101）时，`tree[6][5]`管辖行5-6、列5-5的矩形
            3. 数据结构实现细节
                1. 存储结构
                    - 采用`(n+1)×(m+1)`的二维数组（1-based索引）
                    - 原因：避免`lowbit(0)`的计算错误（0的二进制无1，lowbit为0）
                    - 初始化：所有元素默认值为0，通过`update`操作填充原始数据
                2. 类定义框架
                    
                    ```cpp
                    class Fenwick2D {
                    private:
                        vector<vector<int>> tree;  // 树状数组本体
                        int n, m;                  // 矩阵行数、列数
                        int lowbit(int x) { return x & -x; }  // lowbit实现
                    public:
                        Fenwick2D(int rows, int cols);        // 构造函数
                        void update(int x, int y, int delta); // 单点更新
                        int query(int x, int y);              // 前缀和查询
                        int rangeQuery(int x1, int y1, int x2, int y2); // 区域和查询
                    };
                    ```
                    
            4. 核心操作深度解析
                1. 单点更新（`update(x, y, delta)`）
                    - 功能：给矩阵中`(x,y)`位置的元素增加`delta`值
                    - 原理：所有包含`(x,y)`的父节点都需要同步更新
                    - 步骤：
                        
                        ```cpp
                        void update(int x, int y, int delta) {
                            // 行方向：从x向上遍历所有父节点（i += lowbit(i)）
                            for (int i = x; i <= n; i += lowbit(i)) {
                                // 列方向：从y向上遍历所有父节点（j += lowbit(j)）
                                for (int j = y; j <= m; j += lowbit(j)) {
                                    tree[i][j] += delta;  // 更新当前节点
                                }
                            }
                        }
                        ```
                        
                    - 示例：更新`(2,3)`时，需更新的节点包括：`(2,3) → (2,4) → (4,3) → (4,4) → ...`（直至超出边界）
                2. 前缀和查询（`query(x, y)`）
                    - 功能：计算从`(1,1)`到`(x,y)`的矩形区域总和
                    - 原理：将大矩形分解为多个`tree[i][j]`管辖的小矩形，累加其值
                    - 步骤：
                        
                        ```cpp
                        int query(int x, int y) {
                            int sum = 0;
                            // 行方向：从x向下遍历所有子节点（i -= lowbit(i)）
                            for (int i = x; i > 0; i -= lowbit(i)) {
                                // 列方向：从y向下遍历所有子节点（j -= lowbit(j)）
                                for (int j = y; j > 0; j -= lowbit(j)) {
                                    sum += tree[i][j];  // 累加当前节点值
                                }
                            }
                            return sum;
                        }
                        ```
                        
                    - 示例：查询`(3,3)`时，需累加的节点包括：`(3,3) → (3,2) → (3,0)`（终止），同时行方向会处理`(2,3) → (2,2) → ...`等
                3. 区域和查询（`rangeQuery(x1, y1, x2, y2)`）
                    - 功能：计算矩形`(x1,y1)`到`(x2,y2)`的总和（包含边界）
                    - 原理：利用二维前缀和的容斥原理：
                        
                        ```
                        区域和 = 大前缀和 - 左前缀和 - 上前缀和 + 重叠前缀和
                        ```
                        
                    - 公式实现：
                        
                        ```cpp
                        int rangeQuery(int x1, int y1, int x2, int y2) {
                            return query(x2, y2)          // 大前缀和：(1,1)-(x2,y2)
                                 - query(x1-1, y2)        // 左前缀和：(1,1)-(x1-1,y2)
                                 - query(x2, y1-1)        // 上前缀和：(1,1)-(x2,y1-1)
                                 + query(x1-1, y1-1);     // 重叠前缀和：(1,1)-(x1-1,y1-1)
                        }
                        ```
                        
                    - 边界处理：若`x1 > x2`或`y1 > y2`，返回0（非法区间）
                    
                    > OI-WIKI证明:
                    > 
                    > 
                    > ![image.png](%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image%203.png)
                    > 
            5. 初始化与使用流程
                1. 初始化步骤
                    - 创建`Fenwick2D`对象（指定行数n和列数m）
                    - 对原始矩阵中的每个元素`(i,j)`，调用`update(i,j, val)`插入值
                2. 完整使用示例
                    
                    ```cpp
                    int main() {
                        // 原始矩阵（3×3）
                        int matrix[3][3] = {
                            {1, 2, 3},
                            {4, 5, 6},
                            {7, 8, 9}
                        };
                    
                        // 初始化3×3的二维树状数组
                        Fenwick2D ft(3, 3);
                    
                        // 插入原始数据
                        for (int i = 0; i < 3; i++) {
                            for (int j = 0; j < 3; j++) {
                                ft.update(i+1, j+1, matrix[i][j]);  // 注意1-based索引转换
                            }
                        }
                    
                        // 查询(2,2)到(3,3)的区域和（5+6+8+9=28）
                        cout << ft.rangeQuery(2, 2, 3, 3) << endl;  // 输出28
                    
                        // 更新(2,2)位置+10（5→15）
                        ft.update(2, 2, 10);
                    
                        // 再次查询（15+6+8+9=38）
                        cout << ft.rangeQuery(2, 2, 3, 3) << endl;  // 输出38
                    
                        return 0;
                    }
                    ```
                    
            6. 性能分析与适用场景
                1. 时间复杂度
                    - 单点更新：O(logn · logm)
                    - 前缀和查询：O(logn · logm)
                    - 区域和查询：O(logn · logm)（基于4次前缀和查询）
                2. 空间复杂度
                    - O(n·m)：与原始矩阵规模一致
                3. 适用场景
                    - 动态二维统计（如频繁修改矩阵元素并查询区域和）
                    - 二维频率计数（如统计某矩形内的元素出现次数）
                    - 替代二维前缀和数组（当存在更新操作时）
                4. 局限性
                    - 不直接支持「范围更新」（如给矩形区域所有元素加值），需结合二维差分
                    - 索引必须从1开始，实现时需注意原始数据的索引转换
                    - 对于极端稀疏的矩阵，空间利用率较低
            7. 与其他二维数据结构的对比
                
                
                | 数据结构 | 单点更新 | 区域查询 | 范围更新 | 实现复杂度 |
                | --- | --- | --- | --- | --- |
                | 原始二维数组 | O(1) | O(nm) | O(nm) | 简单 |
                | 二维前缀和数组 | O(nm) | O(1) | O(1) | 简单 |
                | 二维树状数组 | O(logn·logm) | O(logn·logm) | 不直接支持 | 中等 |
                | 二维线段树 | O(logn·logm) | O(logn·logm) | O(logn·logm) | 复杂 |
                
                结论：二维树状数组在「单点更新+区域查询」场景中性价比最高，实现难度低于二维线段树。
                
            8. 常见问题与解决方案
                1. 索引越界
                    - 问题：更新或查询时超出`[1,n]×[1,m]`范围
                    - 解决：在构造函数中记录n和m，循环时严格判断边界
                2. 初始值插入错误
                    - 问题：直接赋值而非调用`update`导致数据错误
                    - 解决：所有原始数据必须通过`update(i,j, val)`插入（因初始值为0）
                3. 容斥公式记错
                    - 问题：区域查询时符号错误或漏加重叠部分
                    - 解决：牢记公式「大减小，减完加回重叠」
        - 二维树状数组(范围修改，范围查询)
            
            支持范围修改与范围查询的二维树状数组是基础二维树状数组的扩展，能够高效处理「矩形区域批量更新」和「矩形区域总和查询」两类操作。其核心思想是结合二维差分与多树状数组组合，将时间复杂度保持在O(logn·logm)级别。
            
            1. 核心原理：二维差分与前缀和推导
                1. 问题定义
                    - 范围修改：给矩形区域`(x1,y1)-(x2,y2)`内所有元素增加`delta`。
                    - 范围查询：计算矩形区域`(x1,y1)-(x2,y2)`内所有元素的总和。
                2. 二维差分的扩展
                    
                    在一维中，范围修改`[l,r] += delta`可通过差分实现（`diff[l] += delta, diff[r+1] -= delta`）。扩展到二维，对矩形`(x1,y1)-(x2,y2)`增加`delta`，对应的二维差分操作是：
                    
                    ```
                    diff[x1][y1] += delta
                    diff[x1][y2+1] -= delta
                    diff[x2+1][y1] -= delta
                    diff[x2+1][y2+1] += delta
                    ```
                    
                    通过对`diff`数组求二维前缀和，可得到原数组的每个元素值。
                    
                3. 范围查询的公式推导
                    
                    设原数组为`a[i][j]`，其值是`diff`数组的前缀和：
                    
                    `a[i][j] = ∑(x=1 to i) ∑(y=1 to j) diff[x][y]`
                    
                    我们需要计算矩形`(x1,y1)-(x2,y2)`的总和`S`，
                    
                    即：`S = ∑(i=x1 to x2) ∑(j=y1 to y2) a[i][j]`
                    
                    代入`a[i][j]`的表达式并交换求和顺序，最终推导可得：
                    
                    `S`可分解为4个关于`diff[x][y]`与系数`(x2-x+1)(y2-y+1)`、`(x2-x+1)`、`(y2-y+1)`、`1`的乘积之和。
                    
                    因此，需要维护4个树状数组，分别存储`diff[x][y]`与不同系数的组合项，以快速计算`S`。
                    
            2. 数据结构设计
                1. 四个基础树状数组
                    
                    为了满足范围查询的公式，需要维护以下4个树状数组（记为`tree1~tree4`）：
                    
                    - `tree1`：存储`diff[x][y] * x * y`
                    - `tree2`：存储`diff[x][y] * x`
                    - `tree3`：存储`diff[x][y] * y`
                    - `tree4`：存储`diff[x][y]`
                    
                    这四个数组分别对应推导公式中的四个项，通过组合它们的前缀和可计算出最终的范围和。
                    
                2. 核心操作设计
                    1. 范围修改（矩形`(x1,y1)-(x2,y2)`增加`delta`）
                        
                        基于二维差分，对四个树状数组执行对应的更新：
                        
                        ```cpp
                        // 对单个点(x,y)执行diff[x][y] += delta，同步更新四个树状数组
                        void point_update(int x, int y, int delta) {
                            tree1.update(x, y, delta * x * y);
                            tree2.update(x, y, delta * x);
                            tree3.update(x, y, delta * y);
                            tree4.update(x, y, delta);
                        }
                        
                        // 范围修改：通过二维差分的4个点更新实现
                        void range_update(int x1, int y1, int x2, int y2, int delta) {
                            point_update(x1, y1, delta);
                            point_update(x1, y2 + 1, -delta);
                            point_update(x2 + 1, y1, -delta);
                            point_update(x2 + 1, y2 + 1, delta);
                        }
                        ```
                        
                    2. 范围查询（矩形`(x1,y1)-(x2,y2)`的总和）
                        
                        利用四个树状数组的前缀和组合计算，公式为：
                        
                        ```
                        sum(x, y) = (x+1)*(y+1)*query1(x,y)
                                   - (y+1)*query2(x,y)
                                   - (x+1)*query3(x,y)
                                   + query4(x,y)
                        ```
                        
                        其中`query1~query4`是四个树状数组的前缀和查询（`(1,1)-(x,y)`的和）。
                        
                        最终矩形`(x1,y1)-(x2,y2)`的总和为：
                        
                        ```cpp
                        int range_query(int x1, int y1, int x2, int y2) {
                            auto calc = [&](int x, int y) {
                                return (x + 1) * (y + 1) * tree1.query(x, y)
                                       - (y + 1) * tree2.query(x, y)
                                       - (x + 1) * tree3.query(x, y)
                                       + tree4.query(x, y);
                            };
                            return calc(x2, y2)
                                   - calc(x1 - 1, y2)
                                   - calc(x2, y1 - 1)
                                   + calc(x1 - 1, y1 - 1);
                        }
                        ```
                        
            3. 完整实现代码
                
                ```cpp
                #include <vector>
                #include <functional>
                using namespace std;
                
                // 基础二维树状数组（支持单点更新和前缀和查询）
                class BasicFenwick2D {
                private:
                    vector<vector<int>> tree;
                    int n, m;
                    int lowbit(int x) { return x & -x; }
                
                public:
                    BasicFenwick2D(int rows, int cols) : n(rows), m(cols) {
                        tree.resize(n + 2, vector<int>(m + 2, 0));  // 预留x2+1、y2+1的空间
                    }
                
                    // 单点更新：(x,y)增加val（1-based）
                    void update(int x, int y, int val) {
                        for (int i = x; i <= n; i += lowbit(i)) {
                            for (int j = y; j <= m; j += lowbit(j)) {
                                tree[i][j] += val;
                            }
                        }
                    }
                
                    // 前缀和查询：(1,1)-(x,y)的和（1-based）
                    int query(int x, int y) {
                        int sum = 0;
                        for (int i = x; i > 0; i -= lowbit(i)) {
                            for (int j = y; j > 0; j -= lowbit(j)) {
                                sum += tree[i][j];
                            }
                        }
                        return sum;
                    }
                };
                
                // 支持范围修改和范围查询的二维树状数组
                class Fenwick2DRange {
                private:
                    BasicFenwick2D tree1, tree2, tree3, tree4;  // 四个基础树状数组
                    int n, m;
                
                    // 内部：对单个点(x,y)执行diff更新（用于范围修改的差分）
                    void point_update(int x, int y, int delta) {
                        tree1.update(x, y, delta * x * y);
                        tree2.update(x, y, delta * x);
                        tree3.update(x, y, delta * y);
                        tree4.update(x, y, delta);
                    }
                
                public:
                    // 构造函数：n行m列（1-based）
                    Fenwick2DRange(int rows, int cols) 
                        : n(rows), m(cols),
                          tree1(rows, cols),
                          tree2(rows, cols),
                          tree3(rows, cols),
                          tree4(rows, cols) {}
                
                    // 范围修改：给矩形(x1,y1)-(x2,y2)内所有元素增加delta
                    void range_update(int x1, int y1, int x2, int y2, int delta) {
                        // 确保索引合法（x2+1和y2+1可能超出n/m，但BasicFenwick2D已预留空间）
                        point_update(x1, y1, delta);
                        if (y2 + 1 <= m) point_update(x1, y2 + 1, -delta);
                        if (x2 + 1 <= n) point_update(x2 + 1, y1, -delta);
                        if (x2 + 1 <= n && y2 + 1 <= m) point_update(x2 + 1, y2 + 1, delta);
                    }
                
                    // 范围查询：计算矩形(x1,y1)-(x2,y2)内所有元素的总和
                    int range_query(int x1, int y1, int x2, int y2) {
                        // 计算(1,1)-(x,y)的前缀和总和
                        auto calc = [&](int x, int y) {
                            if (x < 1 || y < 1) return 0;
                            return (x + 1) * (y + 1) * tree1.query(x, y)
                                   - (y + 1) * tree2.query(x, y)
                                   - (x + 1) * tree3.query(x, y)
                                   + tree4.query(x, y);
                        };
                        // 容斥原理计算目标矩形和
                        return calc(x2, y2) 
                               - calc(x1 - 1, y2) 
                               - calc(x2, y1 - 1) 
                               + calc(x1 - 1, y1 - 1);
                    }
                };
                
                // 使用示例
                #include <iostream>
                int main() {
                    // 创建3×3的二维树状数组（支持范围操作）
                    Fenwick2DRange ft(3, 3);
                
                    // 初始矩阵全为0，执行范围修改：(1,1)-(2,2)增加5
                    ft.range_update(1, 1, 2, 2, 5);
                    // 此时矩阵为：
                    // 5 5 0
                    // 5 5 0
                    // 0 0 0
                
                    // 查询(1,1)-(2,2)的和（5+5+5+5=20）
                    cout << ft.range_query(1, 1, 2, 2) << endl;  // 输出20
                
                    // 再执行范围修改：(2,2)-(3,3)增加3
                    ft.range_update(2, 2, 3, 3, 3);
                    // 此时矩阵为：
                    // 5  5  0
                    // 5  8  3
                    // 0  3  3
                
                    // 查询(2,2)-(3,3)的和（8+3+3+3=17）
                    cout << ft.range_query(2, 2, 3, 3) << endl;  // 输出17
                
                    return 0;
                }
                ```
                
            4. 关键细节解析
                1. 四个树状数组的作用
                    - 推导范围和公式时，`diff[x][y]`会与`(x2-x+1)(y2-y+1)`等系数相乘，拆分为四项：`x*y`、`x`、`y`、`1`。
                    - 四个树状数组分别存储这四项与`diff[x][y]`的乘积，确保查询时可快速组合出结果。
                2. 边界处理
                    - 范围修改时，`x2+1`或`y2+1`可能超出矩阵大小（如`x2=n`时，`x2+1=n+1`），因此基础树状数组的大小设为`(n+2)×(m+2)`，避免越界。
                    - 范围查询时，若`x1=1`或`y1=1`，`x1-1`或`y1-1`可能为0，此时`calc`函数返回0（符合前缀和定义）。
                3. 与基础二维树状数组的对比
                
                | 功能 | 基础二维树状数组 | 支持范围操作的二维树状数组 |
                | --- | --- | --- |
                | 单点更新 | 支持（O(logn·logm)） | 支持（通过范围修改实现） |
                | 范围更新 | 不直接支持 | 支持（O(logn·logm)） |
                | 范围查询 | 支持（O(logn·logm)） | 支持（O(logn·logm)） |
                | 空间复杂度 | O(nm) | O(4nm)（四个树状数组） |
                | 适用场景 | 单点更新+范围查询 | 范围更新+范围查询 |
            5. 应用场景
                - 动态矩阵修改与统计（如游戏地图中某区域的属性批量修改与查询）。
                - 二维区间加减与求和问题（如图像处理中的区域亮度调整与总和计算）。
                - 替代二维线段树（在仅需范围加减和范围求和时，实现更简洁）。
    - 权值树状数组
        
        在C++中，权值树状数组（Weighted Binary Indexed Tree）是一种特殊的数据结构，它结合了树状数组（BIT）的高效特性和权值线段树的统计能力，主要用于处理与元素频率和前缀和相关的问题。
        
        1. 权值树状数组的核心概念
            
            权值树状数组的"权值"指的是数组索引代表的是元素的值（或值的范围），而数组存储的是该值出现的频率或其他相关权重。它特别适合解决以下类型的问题：
            
            - 动态统计元素出现次数
            - 快速查询小于/大于某个值的元素数量
            - 计算逆序对、第k小元素等问题
            
            > OI-WIKI中有关于权值数组的解释:
            > 
            > 
            > ![image.png](%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image%204.png)
            > 
        2. 基本原理
            1. 索引映射：将原始数据的值映射到树状数组的索引
            2. 频率存储：树状数组的每个节点存储对应值的出现频率
            3. 高效操作：利用树状数组的特性实现O(log n)的更新和查询
        3. 实现要点
            1. 数据离散化：由于原始数据可能很大，通常需要先进行离散化处理，将值映射到较小的范围
            2. 树状数组结构：与普通树状数组结构类似，但含义不同
            3. 核心操作：更新（增加/减少某个值的频率）和查询（前缀和/后缀和）
        4. C++实现示例
            
            下面是一个权值树状数组的实现示例，包含离散化处理：
            
            时间复杂度:O(log²n) 
            
            ```cpp
            #include <iostream>
            #include <vector>
            #include <algorithm>
            using namespace std;
            
            class WeightedBIT {
            private:
                vector<int> tree;  // 树状数组
                int size;          // 数组大小
            
                // 计算最低位的1
                int lowbit(int x) {
                    return x & -x;
                }
            
            public:
                // 构造函数
                WeightedBIT(int n) : size(n), tree(n + 1, 0) {}
            
                // 更新操作：在索引i处增加val
                void update(int i, int val) {
                    while (i <= size) {
                        tree[i] += val;
                        i += lowbit(i);
                    }
                }
            
                // 查询操作：查询[1, i]的前缀和
                int query(int i) {
                    int sum = 0;
                    while (i > 0) {
                        sum += tree[i];
                        i -= lowbit(i);
                    }
                    return sum;
                }
            
                // 查询[i, j]的区间和
                int rangeQuery(int i, int j) {
                    if (i > j) return 0;
                    return query(j) - query(i - 1);
                }
            };
            
            // 离散化处理函数
            vector<int> discretize(vector<int>& data) {
                // 复制并排序去重
                vector<int> sorted_data = data;
                sort(sorted_data.begin(), sorted_data.end());
                sorted_data.erase(unique(sorted_data.begin(), sorted_data.end()), sorted_data.end());
            
                // 映射原始数据到离散化后的索引
                vector<int> result(data.size());
                for (int i = 0; i < data.size(); i++) {
                    // 由于树状数组通常从1开始，所以+1
                    result[i] = lower_bound(sorted_data.begin(), sorted_data.end(), data[i]) - sorted_data.begin() + 1;
                }
                return result;
            }
            
            int main() {
                vector<int> data = {5, 2, 9, 1, 5, 6};
            
                // 离散化处理
                vector<int> discretized = discretize(data);
            
                // 创建权值树状数组，大小为离散化后的最大值
                int max_val = *max_element(discretized.begin(), discretized.end());
                WeightedBIT bit(max_val);
            
                // 插入所有元素
                for (int val : discretized) {
                    bit.update(val, 1);
                }
            
                // 查询小于等于6的元素数量
                // 先找到6在离散化后的位置
                int target = 6;
                auto it = lower_bound(data.begin(), data.end(), target);
                // 这里简化处理，实际应根据离散化映射表查找
                int count = bit.query(5);  // 假设6映射到5
                cout << "小于等于6的元素数量: " << count << endl;
            
                // 查询5出现的次数
                int five_count = bit.rangeQuery(3, 3);  // 假设5映射到3
                cout << "5出现的次数: " << five_count << endl;
            
                return 0;
            }
            ```
            
            > OI-WIKI中的全局第k小优化算法：
            时间复杂度O(logn)
            > 
            > 
            > ![image.png](%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image%205.png)
            > 
            > <aside>
            > ✅
            > 
            > 如果需要单点修改测:
            > 
            > ![image.png](%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image%206.png)
            > 
            > </aside>
            > 
        5. 应用场景
            1. 逆序对计数：通过权值树状数组可以高效计算逆序对数量
                
                > OI-WIKI中的分析:
                > 
                > 
                > ![image.png](%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image%207.png)
                > 
                > OI-WIKI中的解答:
                > 
                > ```cpp
                > #include <algorithm>
                > #include <iostream>
                > #include <unordered_map>
                > #include <vector>
                > 
                > // A simple BIT implementation.
                > class BIT {
                >   int n;
                >   std::vector<int> su;
                > 
                >  public:
                >   BIT(int n) : n(n), su(n + 1) {}
                > 
                >   // Add v to the x-th number.
                >   void add(int x, int v) {
                >     for (; x <= n; x += x & (-x)) {
                >       su[x] += v;
                >     }
                >   }
                > 
                >   // Get the cumulative sum till the x-th number.
                >   int query(int x) {
                >     int res = 0;
                >     for (; x; x &= x - 1) {
                >       res += su[x];
                >     }
                >     return res;
                >   }
                > };
                > 
                > // Count inversions.
                > long long solve(const std::vector<int>& nums) {
                >   // Discretization.
                >   std::vector<int> sorted(nums);
                >   std::sort(sorted.begin(), sorted.end());
                >   sorted.erase(std::unique(sorted.begin(), sorted.end()), sorted.end());
                >   std::unordered_map<int, int> ids;
                >   int m = sorted.size();
                >   for (int i = 0; i < m; ++i) {
                >     // Reverse the order.
                >     // Now a smaller id means a larger element.
                >     ids[sorted[i]] = m - i;
                >   }
                >   // Main part.
                >   BIT bit(m);
                >   long long res = 0;
                >   for (int num : nums) {
                >     int id = ids[num];
                >     // Get inversion pair (i,j) with j the current element.
                >     // Namely, count the number of elements larger than
                >     //     the current one but located before it.
                >     res += bit.query(id - 1);
                >     // Insert the current element to the BIT.
                >     bit.add(id, 1);
                >   }
                >   return res;
                > }
                > 
                > int main() {
                >   int n;
                >   std::cin >> n;
                >   std::vector<int> nums(n);
                >   for (int& num : nums) {
                >     std::cin >> num;
                >   }
                >   std::cout << solve(nums);
                >   return 0;
                > }
                > ```
                > 
            2. 动态排名查询：实时查询某个元素在当前数据集中的排名
            3. 频率统计：统计元素出现的次数及相关信息
            4. 第k小元素查询：结合二分查找可以实现第k小元素的查询
        6. 优缺点分析
            1. 优点：
                - 时间效率高：更新和查询操作均为O(log n)
                - 空间效率好：相比权值线段树，空间占用更小
                - 实现相对简单：比线段树更容易实现和维护
            2. 缺点：
                - 需要离散化：处理大范围数据时必须进行离散化
                - 功能有限：相比线段树，不支持某些复杂的区间操作
                - 索引限制：只能处理可以映射到整数索引的值
    - 特殊的树状数组用法(维护不可差分信息)
        
        在C++中，树状数组（Fenwick Tree）是一种高效的区间查询与单点更新数据结构，其核心优势在于O(log n)的时间复杂度。常规树状数组主要用于维护可差分信息（如前缀和、前缀差等），这类信息满足“区间[l, r]的值可通过前缀[r]与前缀[l-1]推导”（如sum(l, r) = sum(r) - sum(l-1)）。
        
        1. 不可差分信息的定义
            
            不可差分信息指无法通过前缀信息间接推导区间信息的类型，例如：
            
            - 最大值/最小值（max(l, r) 无法通过 max(r) 和 max(l-1) 计算）
            - 最大公约数（GCD）/最小公倍数（LCM）（gcd(l, r) 无法通过 gcd(r) 和 gcd(l-1) 计算）
            - 众数、中位数等统计量
        2. 树状数组维护不可差分信息的核心思路
            
            树状数组的本质是通过“节点覆盖特定区间”实现高效操作。对于不可差分信息，核心调整如下：
            
            1. 节点存储内容：每个节点 `tree[i]` 不再存储前缀信息，而是存储其覆盖区间 `[i - lowbit(i) + 1, i]` 的不可差分信息（如区间最大值）。
            2. 更新操作：当更新位置 `i` 时，遍历所有包含 `i` 的节点（通过 `i += lowbit(i)` 向上传递），更新节点存储的信息（如用新值与当前最大值比较）。
            3. 查询操作：查询前缀 `[1, r]` 时，遍历 `r` 覆盖的所有子区间（通过 `r -= lowbit(r)` 向下分解），合并这些区间的信息（如取所有区间最大值的最大值）。
        3. 实例：树状数组维护区间最大值
            
            以“单点更新、前缀最大值查询”为例，详解实现过程。
            
            > OI-WIKI上的关于最大值区间查询的解释:
            > 
            > 
            > ![image.png](%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image%208.png)
            > 
            > OI-WIKI中有关于单点更新的解释:
            > 
            > ![image.png](%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image%209.png)
            > 
            1. 核心原理
                - 节点覆盖范围：对索引 `i`，`lowbit(i) = i & -i`，节点 `tree[i]` 覆盖区间 `[i - lowbit(i) + 1, i]`。
                - 更新逻辑：当位置 `i` 的值更新为 `val` 时，所有包含 `i` 的节点（`i, i+lowbit(i), ...`）需重新计算其区间最大值（新值 `val` 与原最大值比较）。
                - 查询逻辑：查询 `[1, r]` 的最大值时，分解 `r` 为若干个节点的覆盖区间（`r, r-lowbit(r), ...`），取这些区间最大值的最大值。
            2.  C++ 实现代码
                
                ```cpp
                #include <iostream>
                #include <vector>
                #include <algorithm>
                using namespace std;
                
                class FenwickTreeMax {
                private:
                    vector<int> tree;  // 树状数组，存储区间最大值
                    int n;             // 数据规模
                
                    // 计算 lowbit(i) = i & -i
                    int lowbit(int i) {
                        return i & -i;
                    }
                
                public:
                    // 构造函数：初始化树状数组（默认值为-∞）
                    FenwickTreeMax(int size) : n(size), tree(size + 1, -1e9) {}
                
                    // 单点更新：将位置 i 的值更新为 val（1-based 索引）
                    void update(int i, int val) {
                        // 遍历所有包含 i 的节点
                        while (i <= n) {
                            tree[i] = max(tree[i], val);  // 更新当前节点的最大值
                            i += lowbit(i);               // 移动到父节点
                        }
                    }
                
                    // 前缀查询：查询 [1, r] 的最大值（1-based 索引）
                    int query(int r) {
                        int res = -1e9;
                        // 分解 r 为若干个覆盖区间
                        while (r > 0) {
                            res = max(res, tree[r]);  // 合并区间最大值
                            r -= lowbit(r);           // 移动到下一个子区间
                        }
                        return res;
                    }
                };
                
                // 示例用法
                int main() {
                    int n = 5;
                    FenwickTreeMax ft(n);
                
                    // 初始数据：[3, 1, 4, 2, 5]（1-based）
                    ft.update(1, 3);
                    ft.update(2, 1);
                    ft.update(3, 4);
                    ft.update(4, 2);
                    ft.update(5, 5);
                
                    // 查询前缀最大值
                    cout << "前缀[1,3]的最大值：" << ft.query(3) << endl;  // 4（区间[1,3]的最大值为4）
                    cout << "前缀[1,5]的最大值：" << ft.query(5) << endl;  // 5（区间[1,5]的最大值为5）
                
                    // 更新位置2的值为6
                    ft.update(2, 6);
                    cout << "更新后前缀[1,3]的最大值：" << ft.query(3) << endl;  // 6（区间[1,3]的最大值变为6）
                
                    return 0;
                }
                ```
                
        4. 其他不可差分信息的维护
            1. 维护区间GCD
                - 节点存储：`tree[i]` 存储区间 `[i - lowbit(i) + 1, i]` 的GCD。
                - 更新逻辑：当位置 `i` 的值更新时，重新计算所有包含 `i` 的节点的GCD（需遍历节点覆盖区间的所有元素，或利用GCD的结合律优化）。
                - 查询逻辑：查询 `[1, r]` 的GCD时，取所有分解区间的GCD的最大公约数。
            2. 局限性
            - 树状数组仅支持前缀查询，无法直接查询任意区间 `[l, r]` 的不可差分信息（如 `max(l, r)` 无法通过前缀最大值推导）。
            - 若需任意区间查询，建议使用线段树（可分解区间为若干子节点并合并信息）。
        5. 总结
            
            树状数组维护不可差分信息的核心是利用节点覆盖区间存储局部信息，通过更新和查询时的区间遍历实现高效操作。其优势是实现简洁、常数小，适合需频繁单点更新和前缀查询的场景（如动态求前缀最大值）；但受限于前缀查询的特性，无法替代线段树处理任意区间的不可差分信息查询。前缀查询优先树状数组，任意区间查询优先线段树。
            
    - 树状数组中的Tricks建树(O(n))
        
        树状数组（Fenwick Tree）的"Tricks 建树"主要围绕其特殊的索引结构和高效实现展开，核心是通过数组隐性表示树结构，避免显式节点指针操作，从而实现O(log n)的单点更新和区间查询效率。以下是树状数组的关键建树技巧和优化方法：
        
        1. 树状数组的隐性结构与核心原理
            
            树状数组的"树"并非显式构建，而是通过数组索引的二进制特性隐性定义父子关系：
            
            - 每个节点`i`的父节点为`i + lowbit(i)`
            - 每个节点`i`的子节点为`i - lowbit(i)`
            - `lowbit(i)`是`i`二进制表示中最低位1对应的数值（如`lowbit(6)=2`，因`6=110`）
            
            **核心公式**：`lowbit(i) = i & -i`
            
        2. 基础建树方法（初始化）
            
            树状数组的"建树"本质是初始化数组，将原数组元素插入到树状数组中。
            
            **步骤**：
            
            1. 初始化一个大小为`n+1`的数组（树状数组通常从1开始索引）
            2. 对原数组每个元素，通过`update`操作插入到树状数组
            
            **示例代码**：
            
            ```cpp
            #include <vector>
            using namespace std;
            
            class FenwickTree {
            private:
                vector<int> tree; // 树状数组
                int n;            // 原数组长度
            
                // 计算lowbit
                int lowbit(int x) {
                    return x & -x;
                }
            
            public:
                // 构造函数（建树）
                FenwickTree(const vector<int>& arr) {
                    n = arr.size();
                    tree.resize(n + 1, 0); // 索引从1开始
            
                    // 逐个插入元素（O(n log n)初始化）
                    for (int i = 0; i < n; ++i) {
                        update(i + 1, arr[i]); // 原数组索引0对应树状数组1
                    }
                }
            
                // 单点更新：在索引i处增加val（i从1开始）
                void update(int i, int val) {
                    while (i <= n) {
                        tree[i] += val;
                        i += lowbit(i); // 向上更新父节点
                    }
                }
            
                // 前缀查询：查询[1, i]的和（i从1开始）
                int query(int i) {
                    int res = 0;
                    while (i > 0) {
                        res += tree[i];
                        i -= lowbit(i); // 向下累加子节点
                    }
                    return res;
                }
            
                // 区间查询：查询[l, r]的和（原数组索引，从0开始）
                int range_query(int l, int r) {
                    return query(r + 1) - query(l);
                }
            };
            ```
            
        3. 优化建树：O(n)初始化技巧
            
            上述基础方法的初始化时间为O(n log n)，可通过以下技巧优化至O(n)：
            
            **原理**：直接计算每个节点的初始值，而非通过`update`累加。
            
            - 对于节点`i`，其值为原数组中`[i - lowbit(i) + 1, i]`区间的和
            
            **优化代码**：
            
            ```cpp
            FenwickTree(const vector<int>& arr) {
                n = arr.size();
                tree.resize(n + 1, 0);
            
                // 先复制原数组到tree[1..n]
                for (int i = 0; i < n; ++i) {
                    tree[i + 1] = arr[i];
                }
            
                // O(n)初始化：每个节点累加父节点的值
                for (int i = 1; i <= n; ++i) {
                    int j = i + lowbit(i);
                    if (j <= n) {
                        tree[j] += tree[i];
                    }
                }
            }
            ```
            
            > OI-WIKI中的写法:
            > 
            > 
            > ![image.png](%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image%2010.png)
            > 
            > 如果是多组数据可以使用时间戳优化:
            > 
            > ![image.png](%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image%2011.png)
            > 
        4. 多维树状数组（高维建树技巧）
            
            二维树状数组（2D Fenwick Tree）同样有一些“Tricks 建树”技巧，这些技巧主要围绕初始化效率优化、空间压缩和特殊场景适配展开，目的是在保持核心功能的同时提升性能或简化实现。以下是几种典型的二维树状数组建树技巧:
            
            1. 高效初始化：从 O(nm log n log m) 到 O(nm)
                
                标准的二维树状数组初始化通常是通过对每个元素执行 `update` 操作（逐点插入），时间复杂度为 O(nm log n log m)。通过以下技巧可将初始化优化至 O(nm)：
                
                核心思路：
                
                直接计算每个节点的初始值，而非通过迭代更新。对于树状数组中的节点 `(i,j)`，其值等于原始矩阵中 以 `(i,j)` 为右下角、大小为 `lowbit(i) × lowbit(j)` 的子矩阵的元素和。
                
                实现步骤：
                
                1. 先将原始矩阵的值直接复制到树状数组的对应位置（1-based 索引）；
                2. 按行和列分别进行“层叠累加”，利用 `lowbit` 特性直接计算父节点的值。
                
                代码示例（完整初始化逻辑）：
                
                ```cpp
                FenwickTree2D(const vector<vector<int>>& mat) {
                    if (mat.empty() || mat[0].empty()) {
                        throw invalid_argument("矩阵不能为空");
                    }
                    n = mat.size();
                    m = mat[0].size();
                    tree.resize(n + 1, vector<int>(m + 1, 0));
                
                    // 步骤1：复制原始矩阵值到树状数组（1-based索引）
                    for (int i = 1; i <= n; ++i) {
                        for (int j = 1; j <= m; ++j) {
                            tree[i][j] = mat[i - 1][j - 1];
                        }
                    }
                
                    // 步骤2：按行更新父节点（O(nm)）
                    for (int i = 1; i <= n; ++i) {
                        for (int j = 1; j <= m; ++j) {
                            int ni = i + lowbit(i);  // 行方向父节点索引
                            if (ni <= n) {
                                tree[ni][j] += tree[i][j];
                            }
                        }
                    }
                
                    // 步骤3：按列更新父节点（O(nm)）
                    for (int j = 1; j <= m; ++j) {
                        for (int i = 1; i <= n; ++i) {
                            int nj = j + lowbit(j);  // 列方向父节点索引
                            if (nj <= m) {
                                tree[i][nj] += tree[i][j];
                            }
                        }
                    }
                }
                ```
                
                优势：初始化效率提升显著，尤其适合大规模矩阵（如 1000×1000 以上）。
                
            2. 完整二维树状数组示例：
                
                ```cpp
                #include <vector>
                #include <stdexcept>
                
                class FenwickTree2D {
                private:
                    std::vector<std::vector<int>> tree;  // 树状数组存储
                    int n, m;                            // 矩阵的行数和列数（1-based索引）
                    int rows, cols;                      // 原始矩阵的行数和列数（0-based索引）
                
                    // 计算lowbit值
                    int lowbit(int x) const {
                        return x & -x;
                    }
                
                public:
                    // 构造函数：根据输入矩阵初始化树状数组
                    FenwickTree2D(const std::vector<std::vector<int>>& mat) {
                        if (mat.empty() || mat[0].empty()) {
                            throw std::invalid_argument("输入矩阵不能为空");
                        }
                        
                        rows = mat.size();
                        cols = mat[0].size();
                        n = rows;
                        m = cols;
                        
                        // 初始化树状数组，大小为(n+1)x(m+1)，索引从1开始
                        tree.resize(n + 1, std::vector<int>(m + 1, 0));
                        
                        // 第一步：将原始矩阵的值复制到树状数组的对应位置
                        for (int i = 1; i <= n; ++i) {
                            for (int j = 1; j <= m; ++j) {
                                tree[i][j] = mat[i - 1][j - 1];
                            }
                        }
                        
                        // 第二步：O(nm)时间复杂度完成初始化
                        // 按行更新
                        for (int i = 1; i <= n; ++i) {
                            for (int j = 1; j <= m; ++j) {
                                int x = i + lowbit(i);
                                if (x <= n) {
                                    tree[x][j] += tree[i][j];
                                }
                            }
                        }
                        
                        // 按列更新
                        for (int j = 1; j <= m; ++j) {
                            for (int i = 1; i <= n; ++i) {
                                int y = j + lowbit(j);
                                if (y <= m) {
                                    tree[i][y] += tree[i][j];
                                }
                            }
                        }
                    }
                
                    // 单点更新：在(i,j)位置增加val（1-based索引）
                    void update(int i, int j, int val) {
                        if (i < 1 || i > n || j < 1 || j > m) {
                            throw std::out_of_range("更新位置超出范围");
                        }
                        
                        // 先更新行方向
                        for (int x = i; x <= n; x += lowbit(x)) {
                            // 再更新列方向
                            for (int y = j; y <= m; y += lowbit(y)) {
                                tree[x][y] += val;
                            }
                        }
                    }
                
                    // 前缀查询：查询从(1,1)到(i,j)的矩形区域和（1-based索引）
                    int query(int i, int j) const {
                        if (i < 1 || i > n || j < 1 || j > m) {
                            throw std::out_of_range("查询范围超出边界");
                        }
                        
                        int result = 0;
                        // 行方向向上累加
                        for (int x = i; x > 0; x -= lowbit(x)) {
                            // 列方向向上累加
                            for (int y = j; y > 0; y -= lowbit(y)) {
                                result += tree[x][y];
                            }
                        }
                        return result;
                    }
                
                    // 区间查询：查询从(x1,y1)到(x2,y2)的矩形区域和（1-based索引）
                    int rangeQuery(int x1, int y1, int x2, int y2) const {
                        if (x1 > x2 || y1 > y2) {
                            throw std::invalid_argument("无效的查询范围");
                        }
                        
                        // 利用容斥原理计算任意矩形区域的和
                        return query(x2, y2) 
                               - query(x1 - 1, y2) 
                               - query(x2, y1 - 1) 
                               + query(x1 - 1, y1 - 1);
                    }
                
                    // 获取原始矩阵的行数
                    int getRows() const {
                        return rows;
                    }
                
                    // 获取原始矩阵的列数
                    int getCols() const {
                        return cols;
                    }
                };
                ```
                
            3. 空间压缩：针对稀疏矩阵的优化
                
                如果原始矩阵是稀疏矩阵（大部分元素为 0），可通过哈希表替代二维数组存储树状数组，减少空间浪费。
                
                实现思路：
                
                - 用 `unordered_map` 存储非零节点，键为 `i × (m+1) + j`（将二维索引压缩为一维），值为节点的累加和。
                - 仅在需要更新或查询时操作非零节点，避免遍历整个矩阵。
                
                代码片段：
                
                ```cpp
                class SparseFenwickTree2D {
                private:
                    unordered_map<int, int> tree;  // 稀疏存储：key = i*(m+1)+j
                    int n, m;
                
                    int lowbit(int x) { return x & -x; }
                    int key(int i, int j) { return i * (m + 1) + j; }  // 二维转一维键
                
                public:
                    SparseFenwickTree2D(int rows, int cols) : n(rows), m(cols) {}
                
                    void update(int i, int j, int val) {
                        for (int x = i; x <= n; x += lowbit(x)) {
                            for (int y = j; y <= m; y += lowbit(y)) {
                                tree[key(x, y)] += val;  // 仅更新非零节点
                            }
                        }
                    }
                
                    int query(int i, int j) {
                        int res = 0;
                        for (int x = i; x > 0; x -= lowbit(x)) {
                            for (int y = j; y > 0; y -= lowbit(y)) {
                                res += tree[key(x, y)];  // 仅查询存在的节点
                            }
                        }
                        return res;
                    }
                };
                ```
                
                适用场景：矩阵规模极大但稀疏（如地图坐标更新、稀疏数据统计），可节省大量内存。
                
            4. 高维降维：将二维问题转化为一维
                
                对于某些特殊场景（如行或列维度固定），可通过降维技巧简化二维树状数组的实现。
                
                示例场景：若矩阵的行数 `n` 很小（如 `n ≤ 20`），可将每行视为一个独立的一维树状数组，通过“行索引 + 一维树状数组”组合实现二维功能。
                
                代码片段：
                
                ```cpp
                class CompactFenwickTree2D {
                private:
                    vector<FenwickTree1D> rows;  // 每行一个一维树状数组
                    int n, m;
                
                public:
                    CompactFenwickTree2D(const vector<vector<int>>& mat) {
                        n = mat.size();
                        m = mat[0].size();
                        rows.reserve(n);
                        for (const auto& row : mat) {
                            rows.emplace_back(row);  // 每行初始化一个一维树状数组
                        }
                    }
                    
                    // 一维树状数组的update方法（内部实现）
                		void update(int idx, int val) {
                		    while (idx <= m) {  // m是列数
                		        tree[idx] += val;
                		        idx += lowbit(idx);
                		    }
                		}
                
                    void update(int i, int j, int val) {
                        rows[i - 1].update(j, val);  // 直接调用对应行的一维更新
                    }
                
                    int query(int i, int j) {
                        int res = 0;
                        for (int x = 0; x < i; ++x) {  // 累加前i行的前缀和
                            res += rows[x].query(j);
                        }
                        return res;
                    }
                };
                ```
                
                优势：实现简单，利用一维树状数组的成熟逻辑，适合行/列维度较小的场景。
                
            5. 混合操作优化：结合前缀和与树状数组
                
                对于静态矩阵(无更新)的区间查询，可先预处理二维前缀和数组，再用树状数组仅处理动态更新部分，兼顾初始化速度和更新效率。
                
                实现思路：
                
                - 用二维前缀和数组处理静态查询（O(1) 响应）；
                - 用二维树状数组记录所有更新操作（仅存储变化量）；
                - 查询时将两者结果相加，得到最终值。
                
                代码片段：
                
                ```cpp
                class HybridFenwickTree2D {
                private:
                    vector<vector<int>> prefix;  // 静态前缀和
                    FenwickTree2D delta;         // 动态更新的树状数组
                    int n, m;
                
                public:
                    HybridFenwickTree2D(const vector<vector<int>>& mat) : delta(mat) {
                        n = mat.size();
                        m = mat[0].size();
                        // 预处理静态前缀和
                        prefix = vector<vector<int>>(n + 1, vector<int>(m + 1, 0));
                        for (int i = 1; i <= n; ++i) {
                            for (int j = 1; j <= m; ++j) {
                                prefix[i][j] = mat[i-1][j-1] + prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1];
                            }
                        }
                    }
                
                    void update(int i, int j, int val) {
                        delta.update(i, j, val);  // 仅记录更新量
                    }
                
                    int rangeQuery(int x1, int y1, int x2, int y2) {
                        // 静态前缀和 + 动态更新量
                        return (prefix[x2][y2] - prefix[x1-1][y2] - prefix[x2][y1-1] + prefix[x1-1][y1-1])
                             + delta.rangeQuery(x1, y1, x2, y2);
                    }
                };
                ```
                
                适用场景：以静态查询为主、少量动态更新的场景（如日志统计、历史数据查询）。
                
            
            <aside>
            ✅
            
            ### 总结
            
            二维树状数组的“Tricks 建树”技巧本质是根据场景特性选择最优实现：
            
            - 大规模稠密矩阵：优先用 O(nm) 初始化的标准实现；
            - 稀疏矩阵：用哈希表进行空间压缩；
            - 维度不平衡（如行数极少）：通过降维简化实现；
            - 静态为主、动态为辅：结合前缀和与树状数组。
            </aside>
            
        5. 树状数组的扩展技巧
            - **区间更新与单点查询**：通过差分思想，将树状数组维护差分序列，实现区间加、单点查。
            - **逆序对计数**：结合离散化，用树状数组统计每个元素右侧的较小值数量。
            - **动态频率统计**：维护元素出现频率，支持查询小于等于某个值的元素总数。
        
        <aside>
        ✅
        
        ### 总结
        
        树状数组的"Tricks 建树"核心在于：
        
        1. 利用二进制`lowbit`特性隐性定义树结构，避免显式指针
        2. 通过O(n)初始化优化替代O(n log n)的逐点插入
        3. 扩展到多维场景时，采用嵌套循环维护高维索引关系
        </aside>