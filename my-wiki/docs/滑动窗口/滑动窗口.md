## 滑动窗口的定义

所谓滑动窗口就是一种特殊的遍历数组方法，即使用一对指针来标识一个窗口的左右边界，形成一个连续区间。 

滑动窗口的核心点是：窗口的大小，窗口何时移动 (其实窗口状态在窗口移动时具有单调性即(合法 -> 不合法 -> 合法))，如何维护窗口内的元素(左指针移动时窗口排出元素，右指针移动时把元素加入窗口)。

通过对窗口长度来划分，又可以分为**定长**滑动窗口与**不定长**滑动窗口两类。

>   总结：滑动窗口这类题就是要找到：窗口改变的临界条件，窗口的长度，需要维护的信息
>
>   ![滑动窗口题单 双指针题单 力扣题目 灵茶山艾府](https://pic.leetcode.cn/1718242805-sqSjqc-lc1456.png)
>
>   ps 图片引用自：leetcode灵神题单(https://leetcode.cn/discuss/post/3578981/ti-dan-hua-dong-chuang-kou-ding-chang-bu-rzz7/) 

## 定长滑动窗口

定长滑动窗口其实顾名思义也就是窗口长度一定的滑动窗口，一般在题目中会具有鲜明的特点，例如：连续数组/子串/子序列长度为 $k$ 等。
关于这种定长的题目常常以到达长度 $k$ 作为窗口移动状态，然后元素的维护，贡献总计也大多数是在判定条件为 $k$ 时进行操作与维护的。

### 例题

<details> 
    <summary>
    <a href="https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/">灵神题单模板题:1456. 定长子串中元音的最大数目</a>   
    </summary>

​    给你字符串 s 和整数 k 。<br>
​    请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。<br>
​    英文中的 元音字母 为（a, e, i, o, u）。<br>
​    示例 1：<br>
​    输入：s = "abciiidef", k = 3<br>
​    输出：3<br>
​    解释：子字符串 "iii" 包含 3 个元音字母。<br>
​    示例 2：<br>
​    输入：s = "aeiou", k = 2<br>
​    输出：2<br>
​    解释：任意长度为 2 的子字符串都包含 2 个元音字母。<br>
​    示例 3：<br>
​    输入：s = "leetcode", k = 3<br>
​    输出：2<br>
​    解释："lee"、"eet" 和 "ode" 都包含 2 个元音字母。<br>
​    示例 4：<br>
​    输入：s = "rhythms", k = 4<br>
​    输出：0<br>
​    解释：字符串 s 中不含任何元音字母。<br>
​    示例 5：<br>
​    输入：s = "tryhard", k = 4<br>
​    输出：1<br>
​    提示：<br>
​    1 <= s.length <= 10^5<br>
​    s 由小写英文字母组成<br>
​    1 <= k <= s.length<br>
</details>

<details>
    <summary>代码实现</summary>

我们要得到所有长度恰好为 k 的所有子串，最多可以包含多少个元音字母。</br>
那其实题目意思就已经把滑动窗口的类型以及所需要维护的信息都已经明了了。</br>
我们需要维护一个窗口大小固定为 k 的窗口，可以使用一对指针(left, right)来表示左右边界， 维护的信息为窗口内的元音数量，可以使用一个count变量来维护，代码中为了方便判断是不是元音我采取了使用一个集合 set 来存储所有元音。</br>
我们可以通过以窗口长度是否有达到 k 来进行操作，因此每次循环将 right 右移，是窗口长度扩大 1 ，并且判断新进入的元素是不是元音维护 count ,当窗口长度到达 k 时，计算一次 count，然后将 left 右移，是窗口大小缩小为 k - 1，然后同时判断排出去的元素是不是元音从而维护好 count。</br>
优化: 由于是定长滑动窗口其实也可以只使用一个右指针 right 就可以表示, left = right - k + 1。

```cpp
class Solution
{
public:
    int maxVowels(string s, int k)
    {
        unordered_set<char> st = {'a', 'e', 'i', 'o', 'u'};
        int res = 0;
        int n = s.size();
        int cnt = res;
        for (int right = 0; right < n; right++)
        {
            if (st.count(s[right]))
            {
                cnt++;
            }
            if (right < k - 1)
            {
                continue;
            }
            res = max(res, cnt);
            if (st.count(s[right - k + 1]))
            {
                cnt--;
            }
        }
        return res;
    }
};
```

</details>

<details> 
    <summary>
        <a href="https://leetcode.cn/problems/maximum-number-of-occurrences-of-a-substring/">灵神题单模板题:1297. 子串的最大出现次数</a>    
    </summary>

​    给你一个字符串 s ，请你返回满足以下条件且出现次数最大的 任意 子串的出现次数。</br>
​    子串中不同字母的数目必须小于等于 maxLetters 。</br>
​    子串的长度必须大于等于 minSize 且小于等于 maxSize 。</br>
​    示例 1：</br>
​    输入：s = "aababcaab", maxLetters = 2, minSize = 3, maxSize = 4 </br>
​    输出：2 </br>
​    解释：子串 "aab" 在原字符串中出现了 2 次。</br>
​    它满足所有的要求：2 个不同的字母，长度为 3 （在 minSize 和 maxSize 范围内）。</br>
​    示例 2：</br>
​    输入：s = "aaaa", maxLetters = 1, minSize = 3, maxSize = 3 </br>
​    输出：2 </br>
​    解释：子串 "aaa" 在原字符串中出现了 2 次，且它们有重叠部分。</br>
​    示例 3：</br>
​    输入：s = "aabcabcab", maxLetters = 2, minSize = 2, maxSize = 3 </br>
​    输出：3 </br>
​    示例 4：</br>
​    输入：s = "abcde", maxLetters = 2, minSize = 3, maxSize = 3 </br>
​    输出：0 </br>
​    提示：</br>
​    1 <= s.length <= 10^5 </br>
​    1 <= maxLetters <= 26 </br>
​    1 <= minSize <= maxSize <= min(26, s.length) </br>
​    s 只包含小写英文字母。</br>  
</details>

<details>
    <summary>代码实现</summary>

其实本题乍一看好像窗口大小不是固定的，minSize  <= len <= maxSize 为窗口可能的大小，但其实仔细一想，既然他想要最大可能的字串个数。</br>
那么我们是不是应该「贪心」的想一想，如果我想要字串个数我肯定是想要字串越多越好越短越好，因为可以增大发现概率和匹配概率，因此其实也就又回到固定长度的滑动窗口问题，窗口大小为至少子串的长度 minSize。</br>
需要维护的信息有两个: 1.当前窗口中不同字母的数目使用一个 hash表cnt 存储每个字母出现的次数 + count 变量计数，2.每一段子串出现的频率次数使用一个 unordered_map 来存储。</br>
那么其实和上一题思路差别不大，只是需要在计算贡献时不是一到长度为 minLtter 就要算一次，而是需要满足 count <= maxLetter 时才计算当前子串贡献，当前窗口内形成的子串可以使用 substr(right - minSize + 1, minSize); 来获取 </br>

```cpp
class Solution {
public:
    int maxFreq(string s, int maxLetters, int minSize, int maxSize) {
        unordered_map<string,int>hash;
        int n = s.size();
        int cnt[26] = {};
        int count = 0;
        int mx = 0;

        for(int i = 0; i < n; i++)
        {
            if(cnt[s[i] - 'a']++ == 0)
            {
                count++;
            }

            int left = i - minSize + 1;

            if(left < 0)
            {
                continue;
            }

            if(count <= maxLetters) 
            {
                mx = max(mx, ++hash[s.substr(left, minSize)]);
            }

            if(--cnt[s[left] - 'a'] == 0)
            {
                count--;
            }
        }

        return mx;
    }
};
```

</details>



一般题目都会给出窗口具体大小，不过有时会把这个信息隐含在别的语句中，需要自己去稍微拆解之后得到，确定好在滑动窗口中需要维护的信息，滑动窗口适用于连续子段存在合法状态与不合法状态的题目中



[引用]: 引用灵神题单图片

## 不定长的滑动窗口

不定长滑动窗口并没有在题目中具体的长度规定，一般是满足限制条件即为一个窗口的长度，例如：一段连续子串中至少需要包含所有元音字母的最小/最大字串等等，因此在不定长滑动窗口主要可以分为三类问题：求最长子数组，求最短子数组，求满足特定要求的所有子数组个数。

### 最长子数组

一般在这个问题中，一般满足窗口大小**越短越合法**，并且一般都是以限制长度的最大值的条件，也就是**至少**的问题，因此我们窗口的状态大概是 合法 -> 不合法 -> 合法，如果合法就一直移动右指针 $right$ 使数组扩大，如果扩大之后使当前窗口不合法，那么就一直移动左指针直到窗口重新变成合法窗口，每次循环都记一次大小 $(mx = max(mx, right - left + 1))$。

### 例题
<details>
    <summary>
        <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">leetcode灵神题单:3. 无重复字符的最长子串</a> 
    </summary>

​    给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。</br>
​    示例 1: </br>
​    输入: s = "abcabcbb" </br>
​    输出: 3 </br>
​    解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。注意 "bca" 和 "cab" 也是正确答案。</br>
​    示例 2: </br>
​    输入: s = "bbbbb" </br>
​    输出: 1 </br>
​    解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。</br>
​    示例 3: </br>
​    输入: s = "pwwkew" </br>
​    输出: 3 </br>
​    解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。</br>
​        请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。</br>
​    提示：</br>
​    0 <= s.length <= 5 * 10<sup>4</sup> </br>
​    s 由英文字母、数字、符号和空格组成 </br>
</details>

<details>
    <summary>代码实现</summary>

由题目限制条件可得窗口合法状态需要满足不含有重复元素，那么我们需要维护的信息也就是这个窗口内的元素，窗口合法状态为 count = 0,可以使用 hash表cnt 和一个count来记录窗口内的重复元素种类，当count >= 0 时，left就要右移，将窗口缩小直到窗口内的元素没有重复，即 count = 0，每次循环之后记一次长度，即 mx = max(mx, right - left + 1);

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int>hash;
        int len = 0;        
        for(int left = 0, right = 0; right < s.length(); right++)
        {
            hash[s[right]]++;
            while (hash[s[right]] > 1)
            {
                hash[s[left]]--;
                left++;
            }
            len = max(len, right - left + 1);
        }

        return len;
    }
};
```

</details>

### 最短子数组

在这个问题中与上一个问题相反，一般在这个问题中**越长越合法**，并且一般都是限制了窗口的最小长度也就是**至多**的问题，因此我们的窗口状态是 不合法 -> 合法 -> 不合法，如果不合法就一直移动右指针 $right$ 使数组扩大，如果扩大之后使当前窗口合法，那么就一直移动左指针 $left$ 直到窗口重新变成不合法窗口，每次循环都记一次大小 $(mm = min(mm, right - left + 1))$。

### 例题

<details>
    <summary>
        <a href="https://leetcode.cn/problems/minimum-size-subarray-in-infinite-array/">leetcode灵神题单:2875. 无限数组的最短子数组</a> 
    </summary>

​    给你一个下标从 0 开始的数组 nums 和一个整数 target 。</br>
​    下标从 0 开始的数组 infinite_nums 是通过无限地将 nums 的元素追加到自己之后生成的。 </br>
​    请你从 infinite_nums 中找出满足 元素和 等于 target 的 最短 子数组，并返回该子数组的长度。如果不存在满足条件的子数组，返回 -1 。 </br>
​    示例 1： </br>
​    输入：nums = [1,2,3], target = 5 </br>
​    输出：2 </br>
​    解释：在这个例子中 infinite_nums = [1,2,3,1,2,3,1,2,...] 。 </br>
​    区间 [1,2] 内的子数组的元素和等于 target = 5 ，且长度 length = 2 。 </br>
​    可以证明，当元素和等于目标值 target = 5 时，2 是子数组的最短长度。 </br>
​    示例 2： </br>
​    输入：nums = [1,1,1,2,3], target = 4 </br>
​    输出：2 </br>
​    解释：在这个例子中 infinite_nums = [1,1,1,2,3,1,1,1,2,3,1,1,...]. </br>
​    区间 [4,5] 内的子数组的元素和等于 target = 4 ，且长度 length = 2 。 </br>
​    可以证明，当元素和等于目标值 target = 4 时，2 是子数组的最短长度。 </br>
​    示例 3： </br>
​    输入：nums = [2,4,6,8], target = 3 </br>
​    输出：-1 </br>
​    解释：在这个例子中 infinite_nums = [2,4,6,8,2,4,6,8,...] 。 </br>
​    可以证明，不存在元素和等于目标值 target = 3 的子数组。 </br>
​    提示： </br>
​    1 <= nums.length <= 10<sup>5</sup></br>
​    1 <= nums[i] <= 10<sup>5</sup> </br>
​    1 <= target <= 10<sup>9</sup> </br>
</details>

<details>
    <summary>代码实现</summary>

根据题目意思可得这是一个无限循环数组长度为无限长，但其实我们只需要遍历 2 * n 的长度就行，因为窗口内循环节在原数组完全拼接在后面时一定可以全部找到(也就是说因为如果 target 很大，那我们可以先把整个数组之和算出来记作 sum，然后算出倍数 k = target / sum, 以及余数 yu = target % sum 也就是不满足取整个数组段(小于 sum)，其实我们也就是需要找到这个小于一整个数组和的部分如果存在那么我们必然可以在后面拼接 k 段完整的数组),然后又因为他是想要找到元素和为 target 的最短子数组，由此我们可以得到我们需要维护的信息当前窗口内元素和 res, 窗口临界条件为 res > yu, 当 res > yu 时，left就要右移，将窗口缩小直到窗口内元素和 < yu，即 cnt < k，每次循环之后判断是否满足 res == k, 如果等于就更新一下 mm = min(mm, right - left + 1LL);这里有个小细节如果 mm == LLONG_MAX，也就是等于初始值时，证明没有一个子段满足 res == yu，则输出 -1，否则就输出 mm + k * n

```cpp
class Solution
{
public:
    int minSizeSubarray(vector<int> &nums, int target)
    {
        long long int sum = accumulate(nums.begin(), nums.end(), 0LL);

        if (sum == 0)
        {
            return target == 0 ? 1 : -1;
        }

        long long int k = target / sum;
        long long int yu = target % sum;

        long long int mm = LLONG_MAX;
        long long int res = 0;
        int n = nums.size();

        for (int l = 0, r = 0; r < 2 * n; r++)
        {
            res += nums[r % n];

            while (res > yu)
            {
                res -= nums[l % n];
                l++;
            }

            if (res == yu)
            {
                mm = min(mm, r - l + 1LL);
            }
        }

        return mm == LLONG_MAX ? -1 : mm + k * n;
    }
};
```

</details>

### 求子数组个数

在这一类问题中，常常会结合前面两类问题一起考，前面两类只需要找最长/最短的一段子数组长度就行，而这个是要计算所有满足特定条件的子数组的数量，在滑动窗口状态上没有什么差别，只是区别在计算贡献上，大概有以下三类子问题：越长越合法型，越短越合法型，恰好满足型。

#### 越短越合法型

根据上面对越短越合法型的子数组的状态转移(合法 -> 不合法 -> 合法)，当窗口合法时不断移动右指针 $right$ 直到窗口变成非法，由此可得在移动过程中从非法窗口到第一个合法窗口，满足合法窗口的数量有 $left$，那么只需要在求最长子数组的基础上修改贡献语句修改成 $res = res + right - left + 1$ 即可。

#### 例题

<details>
    <summary>
        <a href="https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/">leetcode灵神题单:2302. 统计得分小于 K 的子数组数目</a>   
    </summary>

​    给你一个整数数组 nums 和一个整数 k ，请你返回 nums 中 好 子数组的数目。 </br>
​    一个子数组 arr 如果有 至少 k 对下标 (i, j) 满足 i < j 且 arr[i] == arr[j] ，那么称它是一个 好 子数组。 </br>
​    子数组 是原数组中一段连续 非空 的元素序列。</br>
​    示例 1： </br>
​    输入：nums = [1,1,1,1,1], k = 10 </br>
​    输出：1 </br>
​    解释：唯一的好子数组是这个数组本身。 </br>
​    示例 2： </br>
​    输入：nums = [3,1,4,3,2,2,4], k = 2 </br>
​    输出：4 </br>
​    解释：总共有 4 个不同的好子数组： </br>
​    - [3,1,4,3,2,2] 有 2 对。 </br>
​    - [3,1,4,3,2,2,4] 有 3 对。 </br>
​    - [1,4,3,2,2,4] 有 2 对。 </br>
​    - [4,3,2,2,4] 有 2 对。 </br>
​        提示： </br>
​        1 <= nums.length <= 10<sup>5</sup> </br>
​        1 <= nums[i], k <= 10<sup>9</sup> </br>
​        </details>

<details>
    <summary>代码实现</summary>

我们要找到分数小于 k 的所有非空子数组数目，根据子数组分数计算也就是 sum * size < k，那么我们需要维护的信息也就很明确了只需要维护一个窗口内元素和 sum，长度可以通过 size = right - left + 1 得到，窗口的临界条件就是 sum * size < k，当 sum * (right - left + 1)  >= k 时, left就要右移，将窗口缩小直到窗口内 sum * (right - left + 1) < k，每次循环之后记一次贡献 res += right - left + 1;

```cpp
class Solution
{
public:
    long long countSubarrays(vector<int> &nums, long long k)
    {
        long long int res = 0;
        long long int sum = 0;

        for (int l = 0, r = 0; r < nums.size(); r++)
        {
            sum += nums[r];

            while(l <= r && sum * (r - l + 1) >= k)
            {
                sum -= nums[l++];
            }

            res += (r - l + 1);
        }

        return res;
    }
};
```

</details>

#### 越长越合法型

根据上面对越长越合法型的子数组的状态转移(不合法 -> 合法 -> 不合法)，当窗口合法时不断移动左指针 $left$ 直到窗口变成不合法，由此可得在移动过程中从合法窗口开始一直到非合法窗口，在移动左指针使窗口不合法的过程中，从合法窗口的到不合法窗口的过程中，由于子数组越长越合法，因此所有移动之后在 $left$ 左端开始的子数组都满足条件，因此满足合法窗口的数量有 $left$，那么只需要在求最长子数组的基础上修改贡献语句修改成 $res = res + left$ 即可。

#### 例题

<details>
    <summary>
        <a href="https://leetcode.cn/problems/count-the-number-of-good-subarrays/description/">leetcode灵神题单:2537. 统计好子数组的数目</a>    
    </summary>

​    给你一个整数数组 nums 和一个整数 k ，请你返回 nums 中 好 子数组的数目。 </br>
​    一个子数组 arr 如果有 至少 k 对下标 (i, j) 满足 i < j 且 arr[i] == arr[j] ，那么称它是一个 好 子数组。 </br>
​    子数组 是原数组中一段连续 非空 的元素序列。</br>
​    示例 1： </br>
​    输入：nums = [1,1,1,1,1], k = 10 </br>
​    输出：1 </br>
​    解释：唯一的好子数组是这个数组本身。 </br>
​    示例 2： </br>
​    输入：nums = [3,1,4,3,2,2,4], k = 2 </br>
​    输出：4 </br>
​    解释：总共有 4 个不同的好子数组： </br>
​    - [3,1,4,3,2,2] 有 2 对。 </br>
​    - [3,1,4,3,2,2,4] 有 3 对。 </br>
​    - [1,4,3,2,2,4] 有 2 对。 </br>
​    - [4,3,2,2,4] 有 2 对。 </br>
​        提示： </br>
​        1 <= nums.length <= 10<sup>5</sup> </br>
​        1 <= nums[i], k <= 10<sup>9</sup> </br>
​        </details>

<details>
    <summary>代码实现</summary>

由题目中"至少存在 k 对"可得窗口临界条件，需要维护的信息有相等的对数，那么我们可以使用 hash表unordered_map 来维护窗口中每个数的存在的次数, 窗口合法状态为 cnt >= k, cnt 用来维护存在几对，当cnt >= k 时，left就要右移，将窗口缩小直到窗口内相等元素的元素对数 < k ，即 cnt < k，每次循环之后记一次贡献 res += left;

```cpp
class Solution
{
public:
    long long countGood(vector<int> &nums, int k)
    {
        long long res = 0;
        unordered_map<int, int> hash;

        int l = 0, cnt = 0;
        for(int x : nums)
        {
            cnt += hash[x];
            hash[x]++;

            while(cnt >= k)
            {
                hash[nums[l]]--;
                cnt -= hash[nums[l]];
                l++;
            }

            res += l;
        }

        return res;
    }
};
```

</details>

#### 恰好型

由上面两种类型可得，一个是用来求至少，一个是用来求至多，由于直接求**恰好等于**的滑动窗口并不好求，因为很难用一个具体的条件判断当前到达条件之后应该移动哪一个指针。故而可以转化一下思考，我们发现恰好等于 $k$ 可以转化为两个**至少型**滑动窗口。即：

-   计算有多少个 $>= k$ 的子数组。
-   计算有多少个 $>= k + 1$ 的子数组。

那么这就是我们上面已经学到的越长越合法型的滑动窗口，我们可以有下面两种解决方法：

-   写一个越长越合法型的函数 $f$ ，将临界条件 $k$ 作为函数参数传入，那么可得 $ans = f(k) - f(k + 1)$。
-   或者使用一对指针 $left1$ 和 $left2$，分别来表示两个滑动窗口的窗口边界，也就是三指针法，那么可得 $ans = ans + (right - (left1 - left2))$。

#### 例题

<details>
    <summary>
        <a href="https://leetcode.cn/problems/subarrays-with-k-different-integers/description/">leetcode灵神题单:992. K 个不同整数的子数组</a>  
    </summary>

​    给定一个正整数数组 nums和一个整数 k，返回 nums 中 「好子数组」 的数目。</br>
​    如果 nums 的某个子数组中不同整数的个数恰好为 k，则称 nums 的这个连续、不一定不同的子数组为 「好子数组 」。 </br>
​    例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。 </br>
​    子数组 是数组的 连续 部分。 </br>
​    示例 1： </br>
​    输入：nums = [1,2,1,2,3], k = 2 </br>
​    输出：7 </br>
​    解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]. </br>
​    示例 2： </br>
​    输入：nums = [1,2,1,3,4], k = 3 </br>
​    输出：3 </br>
​    解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4]. </br>
​    提示： </br>
​    1 <= nums.length <= 2 * 10<sup>4</sup> </br>
​    1 <= nums[i], k <= nums.length </br>
</details>

<details>
    <summary>代码实现</summary>

由题目不同整数个数恰好为 k 这一句，可以得到这是"恰好型"滑动窗口，我们可以转化为两个"至少型"滑动窗口，我们可以写一个滑动窗口函数，对于单个窗口来说需要维护的信息就一个窗口内不同元素个数可以使用哈希表unordered_map 和一个 count 计数来实现，窗口临界状态为 count >= k, 当 count >= k 时，就移动 left 缩小窗口内元素减少直到不合法，计算这一段合法子数组贡献为 res += left;那么总的问题答案就是 f(k) - f(k + 1)

```cpp
class Solution
{
public:
    int subarraysWithKDistinct(vector<int> &nums, int k)
    {
        auto f = [&](int x) -> int
        {
            unordered_map<int, int> hash;
            int count = 0;
            int res = 0;

            for (int l = 0, r = 0; r < nums.size(); r++)
            {
                if(hash[nums[r]] == 0)
                {
                    count++;
                }
                hash[nums[r]]++;

                while(count >= x)
                {
                    hash[nums[l]]--;
                    if(hash[nums[l]] == 0)
                    {
                        count--;
                    }
                    l++;
                }

                res += l;
            }

            return res;
        };

        return f(k) - f(k + 1);
    }
};
```

</details>

## 总结

滑动窗口是算法入门的基础，掌握好滑动窗口有助于我们养成编程基础思维，也是后续复杂算法的基石。
题单推荐：[分享丨【算法题单】滑动窗口与双指针（定长/不定长/单序列/双序列/三指针/分组循环）](https://leetcode.cn/discuss/post/3578981/ti-dan-hua-dong-chuang-kou-ding-chang-bu-rzz7/) 建议对于刚刚入门先把滑动窗口内容1700分以下的题目刷完，有能力的可以2000以下。

> ps:查看leetcode难度分数的插件在资源汇总栏有链接下载
