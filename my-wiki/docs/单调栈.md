
# 单调栈

### 单调栈的基本概念

单调栈是一种特殊的栈结构，其核心特点是：栈内元素（或其对应的值）保持单调递增或单调递减的顺序。根据单调性不同，分为两种：
单调递增栈：栈内元素从栈底到栈顶依次递增（即下一个元素比上一个大）。
  单调递减栈：栈内元素从栈底到栈顶依次递减（即下一个元素比上一个小）。
#### 核心思想

通过维护栈的单调性，使得对于栈中的每个元素，其左右侧满足单调性条件的元素可以被快速找到（例如 “下一个更大元素”“下一个更小元素”）。每个元素最多入栈和出栈一次，时间复杂度为 O(n)，远优于暴力枚举的 O(n²)。
    
#### 单调栈的工作流程
    
以单调递增栈为例（寻找每个元素的下一个更大元素），步骤如下：
    
- 初始化栈：用于存储元素下标（通常存下标而非值，方便后续计算位置关系）。
- 遍历数组：
    - 对于当前元素 `nums[i]`，若栈不为空且 `nums[i] > nums[栈顶下标]`，则栈顶元素的 “下一个更大元素” 就是 `nums[i]`，弹出栈顶并记录结果。
    - 重复上述步骤，直到栈为空或当前元素不大于栈顶元素。
    - 将当前元素的下标入栈，继续遍历。

#### 关键性质
- 栈中始终保持元素下标对应的值单调递增。
- 每个元素入栈后，只有当右侧出现 “破坏单调性” 的元素时才会被弹出（即找到右侧第一个更大 / 更小的元素）。

### 分类：单调递增栈与单调递减栈。

- 单调递增栈：栈内元素从栈底到栈顶严格递增（或非递减）
    <details>
    <summary>求下一个大于的数C/C++模板如下</summary> 
    
    ```c
    #include <stdlib.h>
    
    /**
        * 单调递增栈 - 查找右侧第一个大于的元素（处理重复值）
        * @param arr 输入数组（可能包含重复值）
        * @param len 数组长度
        * @return 结果数组，每个位置i存储右方第一个>arr[i]的元素下标，若不存在则为-1
        */
    int* nextGreaterElement(int* arr, int len) {
        int* result = (int*)malloc(len * sizeof(int));
        int* stack = (int*)malloc(len * sizeof(int));
        int top = -1;
        
        for (int i = 0; i < len; i++) {
            result[i] = -1;
            while (top >= 0 && arr[i] > arr[stack[top]]) {
                result[stack[top]] = i;
                top--;
            }
            stack[++top] = i;
        }
        
        free(stack);
        return result;
    }
    
    ```
    
    ```cpp
    #include <vector>
    using namespace std;
    
    /**
        * 单调递增栈 - 查找右侧第一个大于的元素（处理重复值）
        * @param arr 输入数组（可能包含重复值）
        * @return 结果数组，每个位置i存储右方第一个>arr[i]的元素下标，若不存在则为-1
        */
    vector<int> nextGreaterElement(const vector<int>& arr) {
        int n = arr.size();
        vector<int> result(n, -1);
        vector<int> stack;
        
        for (int i = 0; i < n; i++) {
            while (!stack.empty() && arr[i] > arr[stack.back()]) {
                result[stack.back()] = i;
                stack.pop_back();
            }
            stack.push_back(i);
        }
        
        return result;
    }
    ```
    
    </details>

    <details>
    <summary>求上一个大于的数C/C++模板如下</summary>

    ```c
    #include <stdlib.h>
    
    /**
        * 单调递增栈 - 查找左侧第一个大于的元素（处理重复值）
        * @param arr 输入数组（可能包含重复值）
        * @param len 数组长度
        * @return 结果数组，每个位置i存储左方第一个>arr[i]的元素下标，若不存在则为-1
        */
    int* prevGreaterElement(int* arr, int len) {
        int* result = (int*)malloc(len * sizeof(int));
        int* stack = (int*)malloc(len * sizeof(int));
        int top = -1;
        
        for (int i = len - 1; i >= 0; i--) {
            result[i] = -1;
            while (top >= 0 && arr[i] > arr[stack[top]]) {
                result[stack[top]] = i;
                top--;
            }
            stack[++top] = i;
        }
        
        free(stack);
        return result;
    }
    
    ```
    
    ```cpp
    #include <vector>
    using namespace std;
    
    /**
        * 单调递增栈 - 查找左侧第一个大于当前元素的索引
        * @param arr 输入数组（可能包含重复值）
        * @return 结果数组，每个位置i存储左侧第一个>arr[i]的元素下标，若不存在则为-1
        */
    vector<int> prevGreaterElement(const vector<int>& arr) {
        int n = arr.size();
        vector<int> result(n, -1);
        vector<int> stack;
        
        for (int i = n - 1; i >= 0; i--) {
            while (!stack.empty() && arr[i] > arr[stack.back()]) {
                result[stack.back()] = i;
                stack.pop_back();
            }
            stack.push_back(i);
        }
        
        return result;
    }
    ```
    </details>
        
- 单调递减栈：栈内元素从栈底到栈顶严格递减（或非递增）。
    <details>
    <summary>求下一个小于的数C/C++模板如下</summary>
            
    ```c
    #include <stdlib.h>
    
    /**
        * 单调递减栈 - 查找右侧第一个小于的元素（处理重复值）
        * @param arr 输入数组（可能包含重复值）
        * @param len 数组长度
        * @return 结果数组，每个位置i存储右方第一个<arr[i]的元素下标，若不存在则为-1
        */
    int* nextSmallerElement(int* arr, int len) {
        int* result = (int*)malloc(len * sizeof(int));
        int* stack = (int*)malloc(len * sizeof(int));
        int top = -1;
        
        for (int i = 0; i < len; i++) {
            result[i] = -1;
            while (top >= 0 && arr[i] < arr[stack[top]]) {
                result[stack[top]] = i;
                top--;
            }
            stack[++top] = i;
        }
        
        free(stack);
        return result;
    }
    ```
    
    ```cpp
    #include <vector>
    using namespace std;
    
    /**
        * 单调递减栈 - 查找右侧第一个小于当前元素的索引
        * @param arr 输入数组（可能包含重复值）
        * @return 结果数组，每个位置i存储右侧第一个<arr[i]的元素下标，若不存在则为-1
        */
    vector<int> nextSmallerElement(const vector<int>& arr) {
        int n = arr.size();
        vector<int> result(n, -1);
        vector<int> stack;
        
        for (int i = 0; i < n; i++) {
            while (!stack.empty() && arr[i] < arr[stack.back()]) {
                result[stack.back()] = i;
                stack.pop_back();
            }
            stack.push_back(i);
        }
        
        return result;
    }
    ```

    </details>

    
    <details>
    <summary>求上一个小于的数C/C++模板如下</summary>

    ```c
    #include <stdlib.h>
    
    /**
        * 单调递减栈 - 查找左侧第一个小于的元素（处理重复值）
        * @param arr 输入数组（可能包含重复值）
        * @param len 数组长度
        * @return 结果数组，每个位置i存储左方第一个<arr[i]的元素下标，若不存在则为-1
        */
    int* prevGreaterElement(int* arr, int len) {
        int* result = (int*)malloc(len * sizeof(int));
        int* stack = (int*)malloc(len * sizeof(int));
        int top = -1;
        
        for (int i = len - 1; i >= 0; i--) {
            result[i] = -1;
            while (top >= 0 && arr[i] < arr[stack[top]]) {
                result[stack[top]] = i;
                top--;
            }
            stack[++top] = i;
        }
        
        free(stack);
        return result;
    }
    ```
    
    ```cpp
    #include <vector>
    using namespace std;
    
    /**
        * 单调递减栈 - 查找左侧第一个小于当前元素的索引
        * @param arr 输入数组（可能包含重复值）
        * @return 结果数组，每个位置i存储左侧第一个<arr[i]的元素下标，若不存在则为-1
        */
    vector<int> prevSmallerElement(const vector<int>& arr) {
        int n = arr.size();
        vector<int> result(n, -1);
        vector<int> stack;
        
        for (int i = n - 1; i >= 0; i--) {
            while (!stack.empty() && arr[i] < arr[stack.back()]) {
                result[stack.back()] = i;
                stack.pop_back();
            }
            stack.push_back(i);
        }
        
        return result;
    }
    
    ```

    </details>
        
        
- 将上面的板子的返回值索引数组转化为数值数组
    <details>
    <summary>C/C++代码如下</summary>

    ```c
    /**
    * 将下标数组转换为值数组
    * @param arr 原始数组
    * @param indices 下标数组
    * @param n 数组长度
    * @return 值数组，每个位置i的值为indices[i]对应的arr中的值，若indices[i]为-1则为-1
    */
    int* indicesToValues(int* arr, int* indices, int n) 
    {
        int* values = (int*)malloc(n * sizeof(int));
        
        for (int i = 0; i < n; i++) 
        {
            // 根据下标获取对应的值，若下标为-1则结果为-1
            values[i] = indices[i] == -1 ? -1 : arr[indices[i]];
        }
        
        return values;
    }    
    ```

    </details>
        
- 核心操作：入栈前，通过弹出不符合单调性的元素来维护栈的单调性。
### 单调栈的模板题
1. [单调栈_牛客题霸_牛客网](https://www.nowcoder.com/practice/ae25fb47d34144a08a0f8ff67e8e7fb5?tpId=196&tqId=37572&rp=1&ru=/exam/company&qru=/exam/company&sourceUrl=%2Fexam%2Fcompany&difficulty=undefined&judgeStatus=undefined&tags=581&title=)
2. [P5788 【模板】单调栈](https://www.luogu.com.cn/problem/P5788)